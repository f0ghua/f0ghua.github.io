[{"categories":null,"content":"谈到信息安全，我只能算是个门外汉。但是由于工作需求，经常也会接触一些，所以整理一下备查。顺便也把自己的一些心得分享出来。 ","date":"2022-07-01","objectID":"/security/:0:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"关键字 我们在看跟安全相关的文献的时候，最常看到的就是以下的一些词汇。理解它们对于理解相关技术是很重要的。 Confidentiality 保密性 Encrypt 加密 Integrity 完整性（你有没有被篡改过？） Authentication 认证（你是谁？） ","date":"2022-07-01","objectID":"/security/:1:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"相关技术 所有的技术都是为了满足应用的需求而产生。安全技术也不例外。 ","date":"2022-07-01","objectID":"/security/:2:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"对称加密算法 考虑一个场景。A 是一个地下工作者，每隔一段时间，他都要和自己的上线 B 联系传递信息。为了保证信息不被窃听，A 需要把自己的信息加密之后再发送给 B，而 B 要做的就是解密并查看 A 给他的信息。之后 B 同样的也可以加密自己的信息再传递给 A。 这里用到的加解密，最常用的方式就是对称式的加密算法了。也就是双方都拥有一个相同的秘钥（key），然后使用相同的算法来加密或者解密，最终获得明文。 这样的加密算法有很多，通过 man openssl -\u003e Encoding and Cipher Commands 可以看到一些常用的算法列表。 ","date":"2022-07-01","objectID":"/security/:2:1","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"非对称加密算法（公钥加密） 这样的方式很简便快捷，但是存在一个问题。那就是 A 的秘钥每次更新的时候都必须通知 B 以进行同步。这个通知的过程就存在着的泄漏的风险。 于是 A B 在商量之后更新了他们的加密策略，采用了公钥加密算法。 公钥加密算法和对称加密算法不同，包含了 2 个 key。一个私钥（private key）和一个公钥（public key）。公钥可以公开发布，用来加密信息；而私钥只会妥善保存好，用来解密公钥加密的信息。因为私钥不会被传播，所以就解决了对称性加密带来的秘钥泄漏的风险。注意，虽然一般情况下我们都是用公钥加密私钥解密，但是逆过来也是可行的。私钥加密的信息，使用公钥同样可以解密。 比较典型的非对称加密算法就是 RSA 了。 ","date":"2022-07-01","objectID":"/security/:2:2","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"PKI 但是怎么确定 B 拿到的公钥是属于 A 的呢？如果中间有人偷偷把 A 发给 B 的公钥换掉了，那不就可以伪装成 A 了吗？ PKI 隆重登场。PKI 中文译为公钥基础设施，它是英文 Public Key Infrastructure 的缩写，基于公钥密码学，建立起一种普遍适用的基础设施，为各种网络应用提供全面的安全服务。 我们可以简单的认为 PKI 体系就是为了沟通的双方安全的拿到对方的秘钥（真实，完整）。 PKI 基本结构由证书认证机构（certificate authority, CA）、证书持有者（certificate holder）、依赖方（relying party）三方构成 CA 是一个独立的可信第三方，为证书持有者签发数字证书，数字证书中声明了证书持有者的身份和公钥。CA 在签发证书前应对证书持有者的身份信息进行核实验证，并根据其核验结果为其签发证书。 证书持有者向 CA 申请数字证书，并向 CA 提供必要的信息以证明其身份及能力，获得由 CA 签发的证书；证书持有者在与依赖方进行交互时，需向依赖方提供由 CA 签发的数字证书证明其有效身份。 依赖方是证书的验证方，依赖方与证书持有者进行交互（如建立通信连接）时，需获取证书持有者的数字证书，验证数字证书的真实性和有效性。依赖方可以指定其信任的 CA 列表，若证书持有者提供的数字证书不是受信 CA 签发的数字证书，依赖方将不认可该证书所声明的信息。 所以三者的关系，简单来说就如下图： +--------------+ +-----\u003e | CA | \u003c----+ | +----+ +--------------+ | request | | identify | certficiate | | issue certificate | trust | | | | v | | provide | +-------------+ certificate +-------------+ | certificate | +---------\u003e | relay party | | holder | \u003c---------+ | | +-------------+ verifiy +-------------+ certificate 证书存在的意义在于回答“公钥属于谁”的问题，以帮助用户安全地获得对方的公开密钥。 在理解了 PKI 之后，我们再来看 A B 可以如何交互 私钥(key - private key) 证书请求(csr - certificate signing request) 签名证书(crt - certificate signed request) \r A CA B + + + | | | generate a pair | | | of keys | | | | send csr | | | +-------------------\u003e | | | | | | 1. verify identity | | | 2. sign the csr | | | 3. send back the cer | | | \u003c-------------------+ | | | | | | | | | send A's crt to B | | | +----------------------------\u003e | 1. verify with CA's cert | | | 2. store A's public key | | | | | | | send data to A| | decrypt with A's | \u003c----------------------------+ | encrypt data with private key | | | A's public key | | | | | | | | | | | | + + + 图示只标注了 B 往 A 发送数据的过程，如果是 A 往 B 传递信息，那么同样的方法，只是换成使用 B 的 key 而已。 在这里面还有几点需要说明的 所谓的签名，其实可以简单的理解成把原始证书先做 hash，再使用 CA 的 private key 对这个 hash 值进行加密，最后添加到证书里面的一个过程 证书可以由 CA 签名，也可以自签名 证书一般使用 X509 的格式，其中中包含了持有者的公钥和发布者的签名，以及其他的一些表明证书身份相关的信息 CA CA 分为 Signed CA 和 Self Signed CA。两者的差别在于其证书（certificate）被认证的方式不同。 Self Signed CA 是指由自己给自己的 certificate 做签名认证的 CA ，由于一般来讲此类 CA 总是处于 CA 链的最顶端，所以又叫 Root CA。 Signed CA 是指 certificate 由其他 CA 进行签名认证的 CA。而认证它的 CA，我们称为 Signed CA 的上层 CA，也叫 Parent CA；而 Signed CA 则称为 Sub CA 或 Child CA。 ","date":"2022-07-01","objectID":"/security/:2:3","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"实例说明 ","date":"2022-07-01","objectID":"/security/:3:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"PKI 下面，就用 openssl 举例生成 RSA 的 CA 和用户证书。 生成 CA 的私钥 [fog@fog-ibm ca] openssl genrsa -des3 -out ca.key 1024 Generating RSA private key, 1024 bit long modulus ...........................+++++ ............................................+++++ e is 65537 (0x10001) Enter PEM pass phrase: Verifying password - Enter PEM pass phrase: Please backup this ca.key file and remember the pass-phrase you had to enter at a secure location. 生成 CA 的自我签名证书 fog@tmp$ openssl req -new -x509 -days 365 -key ca.key -out ca.crt Enter pass phrase for ca.key: You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [AU]: State or Province Name (full name) [Some-State]: Locality Name (eg, city) []: Organization Name (eg, company) [Internet Widgits Pty Ltd]: Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []:Fog Email Address []: 查看一下生成的证书 fog@tmp$ openssl x509 -noout -text -in ca.crt Certificate: Data: Version: 3 (0x2) Serial Number: 6c:5b:7a:5c:37:e3:1b:2d:99:2d:99:20:79:54:c4:d6:52:9e:20:17 Signature Algorithm: sha256WithRSAEncryption Issuer: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog Validity Not Before: Jul 5 08:43:44 2022 GMT Not After : Jul 5 08:43:44 2023 GMT Subject: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (1024 bit) Modulus: 00:c2:ad:39:a9:64:a5:85:5b:39:ab:eb:a8:da:82: 66:90:60:f9:35:d9:ea:67:4e:6f:d6:99:14:1c:32: 6a:23:e4:03:eb:11:44:1a:94:4d:42:a1:74:9e:26: 62:10:0b:4b:a8:3c:10:28:32:c9:d9:1b:34:aa:03: 5d:d6:63:70:32:68:c0:d2:9d:17:e7:b4:47:6e:6e: 86:66:a5:bc:f1:52:4e:2a:47:2a:0e:7b:00:d7:f9: d0:70:c2:12:58🆎df:b3:82:51:23:cf:a8:59:40: c6:a7:7e:f6:8c:91:1e:00:42:87:d1:42:1c:98:15: 4e:ff:1c:38:55:8a:d1:9d:fb Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 3F:46:C9:DA:5C:4E:60:65:CB:48:8E:DF:FE:92:67:2C:03:A4:B0:A1 X509v3 Authority Key Identifier: keyid:3F:46:C9:DA:5C:4E:60:65:CB:48:8E:DF:FE:92:67:2C:03:A4:B0:A1 X509v3 Basic Constraints: critical CA:TRUE Signature Algorithm: sha256WithRSAEncryption 72:98:2c:4b:ac:5d:3e:aa:21:ca:5f:46:1a:b9:14:2c:2f:b8: e9:3d:8a:bd:19:ea:da:32:13:fc:02:9c:f7:f2:2b:99:56:20: 11:86:5b:7c:1b:ea:5a:0e:f4:bd:da:e2:44:ec:b9:71:7b:3a: 01:a3:d1:dc:bc:fc:52:49:6a:c8:f4:2c:27:45:ab:e6:65:bf: 75:75:1e:66:56:cc:82:71:95:7f:0b:da:8a:bf:2d:b6:7b:fd: 72:a2:68:f5:13:59:6f:ac:72:20:bf:59:0c:20:60:3d:46:6e: d7:4c:83:90:42🆎04:b9:e1:e4:9f:1c:7e:1e:2f:96:32:b0: 89:6e 这里我们就可以看到一个 x509 格式的证书包含了哪些字段。这个对于理解证书很重要，所以详细分析一下 Issuer: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog Subject: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog 因为这是一个自签名的证书，所以 Issuer 和 Subject 的内容是一样（Issuer 表示是谁颁发的证书，而 Subject 表示这个证书属于谁）。 Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (1024 bit) Public Key Info 告诉我们这个 Public Key 对应的加密算法是 RSA，秘钥为 1024 bit，然后明文附上了对应的秘钥（注意这是秘钥对里面的 public key）。 X509v3 extensions: X509v3 Basic Constraints: critical CA:TRUE 这里可以看到 CA 的值是 TRUE，表示这个证书可以作为 CA 证书使用。 Signature Algorithm: sha256WithRSAEncryption 签名的算法为先用 sha256 做 hash 算法，然后再用 RSA 算法使用 Issuer 的 private key 进行加密。 生成用户的私有密钥 fog@tmp$ openssl genrsa -des3 -out my.key 1024 生成用户的签名请求证书 fog@tmp$ openssl req -new -key my.key -out my.csr 由 CA 为请求证书签名 fog@tmp$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in my.csr -out my.crt -days 365 现在再来看看这个生成的证书是什么样的 fog@tmp$ openssl x509 -noout -text -in my.crt Certificate: Data: Version: 1 (0x0) Serial Number: 14:a2:7c:94:fa:b8:0c:28:0d:9b:c3:86:44:3a:cf:40:0e:ea:71:c3 Signature Algorithm: sha256WithRSAEncryption Issuer: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog Valid","date":"2022-07-01","objectID":"/security/:3:1","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"Reference Difference between self-signed CA and self-signed certificate TLS encryption and mutual authentication using syslog-ng Open Source Edition Making sense of SSL, RSA, X509 and CSR A journey into verifying signatures on x.509 certificates ","date":"2022-07-01","objectID":"/security/:4:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":["programming"],"content":"函数原型 #include \u003cstring.h\u003e char *strncpy(char *dest, const char *src, size_t n); ","date":"2022-06-30","objectID":"/strncpy/:1:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"用法分析 strncpy 由于添加了长度限制，避免了缓冲区溢出的问题。但在使用这个函数的时候必须要注意: strncpy 只有在源字符串的长度小于参数 n 时，它才会用 NUL(或者'\\0')来结束字符串。 因此正确的使用 strncpy 的方法是，当拷贝源字符串的一部分时，使用 strncpy 之后，自己手工添加 NUL 来结束字符串。 #define BUFSIZ 265 int main(int argc, char **argv) { char buf[BUFSIZ]; strncpy(buf, argv[1], sizeof(buf) - 1); buf[sizeof(buf) - 1] = '\\0'; /* 防止buf没有初始化为0，结束字符串 */ return 0; } 这里可以看到，要正确使用 strncpy 还是挺麻烦的一件事情。 ","date":"2022-06-30","objectID":"/strncpy/:2:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"注意事项 ","date":"2022-06-30","objectID":"/strncpy/:3:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"strlcpy 其实在 openbsd 里面提供了一个库函数 strlcpy 。它保证了目的字串总是以 NUL 结尾，并且返回值总是目的字串的全长(不包括 NUL)。其源码如下 /* $OpenBSD: strlcpy.c,v 1.11 2006/05/05 15:27:38 millert Exp $ */ /* * Copyright (c) 1998 Todd C. Miller \u003cTodd.Miller@courtesan.com\u003e * * Permission to use, copy, modify, and distribute this software for any * purpose with or without fee is hereby granted, provided that the above * copyright notice and this permission notice appear in all copies. * * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */ #include \u003csys/types.h\u003e#include \u003cstring.h\u003e /* * Copy src to string dst of size siz. At most siz-1 characters * will be copied. Always NUL terminates (unless siz == 0). * Returns strlen(src); if retval \u003e= siz, truncation occurred. */ size_t strlcpy(char *dst, const char *src, size_t siz) { char *d = dst; const char *s = src; size_t n = siz; /* Copy as many bytes as will fit */ if (n != 0) { while (--n != 0) { if ((*d++ = *s++) == '\\0') break; } } /* Not enough room in dst, add NUL and traverse rest of src */ if (n == 0) { if (siz != 0) *d = '\\0'; /* NUL-terminate dst */ while (*s++) ; } return(s - src - 1); /* count does not include NUL */ } ","date":"2022-06-30","objectID":"/strncpy/:3:1","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"strncpy vs snprintf 除了使用 strlcpy，还有个好的选择是使用 snprintf。 snprinf 可以完成 strncpy 的功能，而且比 strncpy 更有效率。看一下 glibc 中 strncpy 的代码 char * STRNCPY (char *s1, const char *s2, size_t n) { size_t size = __strnlen (s2, n); if (size != n) memset (s1 + size, '\\0', n - size); return memcpy (s1, s2, size); } 我们可以看到，当 s2 的长度小于 n 的时候，strncpy 会把 s1 中从 s2 的长度以后的所有字节都设置成 '\\0' ，显然，这个对于我们大部分情况下的需求来说是没有必要的，只要将字符串的最后一个字节置 NULL 即可。这也是 snprinf 的做法。 ","date":"2022-06-30","objectID":"/strncpy/:3:2","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["network"],"content":"概述 ","date":"2022-02-07","objectID":"/wireless/:1:0","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"从一次正常的连接说起 先从一次简单的连接看起。测试环境就是一台无线 STA 和一个 AP，以及一台用来抓包的 PC 。 +--------+ +-------+ | STA | | AP | +--------+ +-------+ +---------+ | capture | | PC | +---------+ 通过 PC 用 wireshark 来抓取 STA 和 AP 之间的无线数据报文。 ","date":"2022-02-07","objectID":"/wireless/:2:0","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"管理报文 先看看管理报文 Wireless Management PacketsWireless Management Packets \" Wireless Management Packets ","date":"2022-02-07","objectID":"/wireless/:2:1","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"数据报文 ","date":"2022-02-07","objectID":"/wireless/:2:2","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"附录 ","date":"2022-02-07","objectID":"/wireless/:3:0","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"Linux 抓无线包 ","date":"2022-02-07","objectID":"/wireless/:3:1","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"Wireshark 解密无线包 ","date":"2022-02-07","objectID":"/wireless/:3:2","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e /* 函数说明: 按照format指定的格式填充字符串str，以 '\\0' 结尾。 函数返回值: 若成功则返回存入数组的字符数，若编码出错则返回负值。 */ int sprintf(char *str, const char *format, ...); ","date":"2022-02-07","objectID":"/sprintf/:1:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"用法分析 sprintf 一般用来把其他类型的数据转换成字符数组储存。它会自动在所写入字符组的末尾加上 NUL 字符来表示字符串的结束，NUL 字符不被计入返回值。 sprintf 和 strcpy 一样，属于无边界检查的一类函数，不建议使用。 ","date":"2022-02-07","objectID":"/sprintf/:2:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"注意事项 对于新写的代码，请抛弃 sprintf，用 snprintf 代替。 ","date":"2022-02-07","objectID":"/sprintf/:3:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"函数原型 #include \u003cstring.h\u003e char *strcpy(char *dest, const char *src); ","date":"2022-02-07","objectID":"/strcpy/:1:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"用法分析 strcpy 属于无边界检查的一类函数，因此使用起来十分的危险，在标准文档中已经不建议使用。 无边界检查很容易就会发生缓冲溢出的错误，例如: #define BUFSIZ 265 int main(int argc, char **argv) { char buf[BUFSIZ]; strcpy(buf, argv[1]); return 0; } 注意这个例子中 buf 定义了大小为 256，但是 argv[1]却是不限制大小的。由于 strcpy 只知道拷贝到源字串结束，因此一旦 argv[1]的长度大于 BUFSIZ，就会引起缓冲溢出了。 ","date":"2022-02-07","objectID":"/strcpy/:2:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"注意事项 请抛弃 strcpy，用 strncpy 代替，最好用 strlcpy。 ","date":"2022-02-07","objectID":"/strcpy/:3:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e int sscanf(const char *str, const char *format, ...); 这里 format 可以是一个或者多个 { %[*][width][{h|l|I64|L}]type | ' ' | '\\t' | '\\n' | 非%符号 } 其中 符号 说明 * 添加则表示满足条件的被过滤 width 表示宽度 h 表示单字节 l 表示双字节 L 表示 4 个字节 I64 表示 8 个字节 type 如 s, d 之类，表示字符串等 ","date":"2022-02-05","objectID":"/sscanf/:1:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"用法分析 ","date":"2022-02-05","objectID":"/sscanf/:2:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"基本用法 sscanf 一般用来从一个 ascii 字符串中读取一些值，基本用法很简单。例如 #include \u003cstdio.h\u003e int main () { char *str = \"121000-13:00:20\"; int s[6]; int i; sscanf(str,\"%2d%2d%2d-%d:%d:%d\", \u0026s[0],\u0026s[1],\u0026s[2],\u0026s[3],\u0026s[4],\u0026s[5]); for(i = 0;i \u003c 6;i++) printf(\"s[%d] = %d\\n\",i,s[i]); return 0; } ","date":"2022-02-05","objectID":"/sscanf/:2:1","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"高级用法 sscanf 提供了简单的模式匹配，其格式为 %[] 。 这里的 [ ] 和正则表达式中是一样的，表示匹配其中出现的字符序列。如果在 [ ] 中使用 ^ ，则是表示取反。 例如: [a-z] 表示小写字母序列,如abc ... [^a-z] 表示除小写字母的字符 举例来说明 #include \u003cstdio.h\u003e int main () { char *str = \"12:10:00-13:00:20\"; char s[6][3]; int i; sscanf(str,\"%[^:]:%[^:]:%[^-]-%[^:]:%[^:]:%[^:]\", s[0],s[1],s[2],s[3],s[4],s[5]); for(i = 0;i \u003c 6;i++) printf(\"s[%d] = %s\\n\",i,s[i]); return 0; } 这个例子分隔出了 str 字符串中的所有数字。其格式字符串分析如下： %[^:] 表示匹配不含 : 的字符串,所以第一个 %[^:] 就匹配了数字字符串 12 ,第二个则匹配了 10 ; 同理， %[^-] 表示匹配不含 - 的字符串,所以匹配字符串 13 ；其他的就不言而寓了。 还是上面的例子，如果我们把格式化字串变为 %[0-9]:%[0-9]:%[0-9]-%[0-9]:%[0-9]:%[0-9] , 将会如何？嘿嘿，一样的结果。因为 %[0-9] 就匹配了数字组成的字符串。 相信这一个例子应该足够说明问题，具体情况具体分析，主要还是靠大家活学活用了。 再举一个复杂点的例子，供参考： #include \u003cstdio.h\u003e /* 获取/和@之间的字符串 */ int main() { const char *s = \"iios/12DDWDFF@122\"; char buf[20]; sscanf(s, \"%*[^/]/%[^@]\", buf); printf(\"%s\\n\", buf); return 0; } ","date":"2022-02-05","objectID":"/sscanf/:2:2","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"注意事项 ","date":"2022-02-05","objectID":"/sscanf/:3:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"返回值检查 我们在使用 sscanf 的时候往往会忽略其返回值，事实上，sscanf 的返回值是很有用处的。 当匹配出错的时候其返回值为 EOF，否则返回匹配成功的参数个数，如够一个都没匹配到，就是 0 了。 举例子如下： int main(int argc, char **argv) { int i = 0, j = 0, r; r = sscanf(argv[1], \"%d:%d\", \u0026i, \u0026j); printf(\"r = %d, i = %d, j = %d\\n\", r, i, j); return 0; } 执行结果如下 $ ./main a r = 0, i = 0, j = 0 $ ./main 1 r = 1, i = 1, j = 0 $ ./main 1:2 r = 2, i = 1, j = 2 ","date":"2022-02-05","objectID":"/sscanf/:3:1","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"溢出问题 sscanf 最为人诟病的地方，是很容易出现缓冲区溢出错误。实际上 sscanf 是可以避免出现缓冲区溢出的，只要在书写任何字符串解析的格式时，注意加上其缓冲区尺寸的限制。如 #include \u003cstdio.h\u003e int main() { char match[8] = \"12345678\"; // fill with values to test with terminating // null character int len = sizeof(match)-1; const char *input = \"hello world\"; char format[16]; snprintf(format, sizeof(format), \"%%%d[a-z ]\", len); printf(\"format = %s\\n\", format); sscanf(input, format, match); printf(\"match = %s\\n\", match); } 输出为 format = %7[a-z ] match = hello w 这里 format 里面的 %7 就限定了拷贝过来的字符串长度为 7 ，也就是 match 的总长减一。 最后一个字符留给字符串的结尾字符 \\0 ，sscanf 会自动添加。 ","date":"2022-02-05","objectID":"/sscanf/:3:2","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["study"],"content":"概述 由于新公司的国外业务占比很高，因此要求托业要过 600 才行。所以入职后前后参加了 2 次考试，分别为 2021.8.24 和 2022.1.16 月份。第一次考了 560 分（250/310），第二次 730 分（350/380）。记录这份文件的目的主要是分享下考试经验，帮助跟我水平类似的人通过托业的考试。 第一次考试基本没做什么准备，只是考前熟悉了一下题型。而从第一次考试到第二次考试，期间虽然间隔了差不多 5 个月的时间，但真正用来复习的也就差不多最后一个多月。因为第二次考试其实是临时决定的，原本的计划是 2022 年后才开始备考。所以这个分享我觉得对于短时间备考的同学更有帮助一些。废话就不多说了，我们开始。 ","date":"2022-02-05","objectID":"/toeic_experience/:1:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"备考经验 ","date":"2022-02-05","objectID":"/toeic_experience/:2:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"原则 拿好你懂的分数，模糊的或者不懂的不要恋战。掌握好时间，题目最多过 2 遍，2遍了还不确定，直接猜，不要逗留 每一题都要当时就填，不懂就猜，不要留空，因为你后面没时间回头填 ","date":"2022-02-05","objectID":"/toeic_experience/:2:1","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"准备工作 考试前先准备好 2 支铅笔和橡皮。铅笔自己考前先试好，确认涂圆形的答题项顺滑。这点我认为很重要，因为如果削的太尖了，涂起来浪费时间，擦起来又不方便。 考试全程都是播放的录音指导考试过程，全英文，建议没考过的同学先做下模拟题熟悉一下旁白的内容。这样你可以知道，哪些时间是你可以利用起来看题或者休息。 进入考场后，桌子上会放有写有准考证号的纸条和你的答题卡。答题卡上的正面以及反面的上半部分都是一些个人信息以及托业官方的调查信息，然后才是题目答案。考前，会有专门的时间（大约 15 分钟）录音指导一步步的填写除答题以外的部分。但是我建议可以乘等待的时间先把答题卡填起来，因为答题卡上有一项需要抄写声明，对于书写慢的同学来说还是有点紧的，为不影响考试情绪，建议提前写好。这时候监考老师一般是不会管的。虽然第一次考试的时候，老师说先不要填写，但是填了也没关系。 我参加的 2 次考试，一次在公司，一次是在外面（托业指定的社会考试地点，某旅店的宴会厅）。考试环境都很安静，基本不会出现一些人提到的外界声音干扰什么的问题，所以这点不用担心。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:2","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"时间分配 托业题量很大，如果不熟悉，根本是来不及做完的。比如我第一次，就整整留下来 5 大题的阅读没有完成。而第二次，经过了练习以后也还是省下了最后 3 道选择题没看，结果是乱填的。所以时间分配很重要。 总时间是 120 分钟，其中 45 分钟听力，75 分钟阅读。 听力 听力其实没什么好说的，因为都是一题一题的过，需要注意的是以下几点关于网上介绍的考试技巧的体会 利用旁白的时间先看看后面要做的题目，比如图片题的图片，短文问答题的问题以及答案。因为旁白的时间一般都比较长，浪费了有点可惜，看看后面的内容也无妨，但是不要抱多大期待。因为对我这样的英文基础，其实看不看影响真的不大。听力好的同学不妨使用。 利用上一题剩下的时间预先审下一题。这个对我来说就太难了，实际操作下来基本没啥用处，做完上一题，基本不剩几秒了，看一下题太过勉强，别费那个心了。(人家的操作是在听短文的时候顺便就把问题做完了，短文结束读问题的时候就跳到下一题去看问题了。我根本做不到听短文的时候还去答问题，一分心短文都听不完整了) 阅读 阅读的 75 分钟时间，建议这样分配，在练习中就通过倒计时来熟悉。 大题 题型 题数 时间 5 句子填空 30 (101~130) 10 分钟 (20 秒一题) 6 短文填空 16 (131~146) 5 分钟 7 单篇阅读(10 篇) 29（147~175） 30 分钟 (3 分钟一篇) 7 多篇阅读(5 篇) 25 (176~200) 30 分钟（5 分钟一篇） ","date":"2022-02-05","objectID":"/toeic_experience/:2:3","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"其他 词汇量 词汇量不是一个月两个月就能提高的。但是对于托业来说，我觉得最好的方式是刷题，然后从题目中记录单词。只是针对这些生词来记忆，可以短期内提高托业的成绩。 听力 说实话，两次考试，我自我觉得听力其实没多少提高，这个确实是硬实力，需要不断的磨耳朵才行。听力上我的建议是针对 Part1 和 Part2 多练习，因为这两项是可以在短期内提高的，而 Part3 和 Part4，有时间就多练多听，没时间。。。就蒙吧，反正我第二次考试 Part3 和 Part4 真正听懂的很少。 另外几个相关的技巧供参考 有的同学记忆不好，比如听到了 A 不确定，听到了 C 又不确定，到听完 D 的时候忘记了 B 是对的还是错的了，猜题的时候就不知道该猜哪个了。考题本和答题卡上都不能做记号，这里有个办法，就是用手指来表示 ABCD，比如左手大拇指表示 A，食指表示 B，依次类推。每一题读完，就用手指的状态表示是否错误。比如如果 A 确定是错的，那么就把大拇指弯曲，B不确定那就保持直着，C错误那就弯曲中指，最后 D 也不确定，那就 BD 里面猜。 对于 Part2 ，关键就是在于听清楚第一个词，4W1H，即 What， Who，Where，When 以及 How 。听清楚了这 4 个词就有 80% 以上的机会答对了。 阅读 单句填空主要是考 单词/文法/词性，所以先知道考点很重要。建议先看答案，再看题。这样有的题目可能马上就能知道答案了，甚至都不需要知道单词是什么意思。这点刷题后自然会有体会。 单篇阅读和多篇阅读也是建议先看题再到文章中去找答案。这样感觉还是要快很多。平时练习可以看一下自己的速度，如果来不及，那么就放弃那些需要看全篇才能找答案的题目。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:4","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"备考资料 先说重点，备考资料里我觉得最有用的就是书和 abceed。 书 \r 2021 新托业模拟题库 我只买了这一套。并且只做了 Part5-Part7 的那两本。前面的听力部分我都是靠手机端软件 abceed 来熟悉。 移动端 \r 背单词：不背单词 + Anki 我背单词的主力软件是不背单词，所有从托业刷题过来的生词都加到生词本，然后每天早上花半小时左右时间复习。 Anki 作为不背单词的补充。因为不背单词有些生词会找不到，所以需要手动记录到 Anki 上进行记忆。当然，托业中遇到的语法，词组等等也都可以记录在 Anki 上。 \r 刷题：abceed + QuizFun 考尚乐 首先我用的是 iphone，这两个软件都需要美区账户才能下载。 abceed 是一个日本人写的软件，可以说是托业最好的移动端软件了，缺点是收费和具体说明文字为日文。软件可以定目标，随时刷题，并即时调整你的成绩。充分的利用碎片时间熟悉题型。我觉得对于听力部分的练习很有用处。而阅读的部分，由于我用的是手机，往往看文章的时候由于显示不全得翻页，严重影响了体验，所以阅读部分对我的帮助应该主要还是在于熟悉题型和收集生词。用 ipad 应该会好很多。建议如果基础不太好的同学花 3 个月左右的时间备考，可以买 3 个月，大概人民币 400 不到，比单月买的便宜很多。 考尚乐 则是台湾人做的一个软件，在台湾托业叫做多益，所以搜考题的时候直接搜多益就可以了。这个软件也是收费的，但是有一些免费的可以用来练习。这个软件我是后来才知道的，所以只是作为一个补充使用。它比 abceed 好的地方在于都是中文解析，不好的地方在于题目有些老，感觉难度相比实际考试偏高。 电脑端 我第一次考试前在淘宝买了一个托业的软件，可以做模拟试题。大概 10 几套试卷，而且每个都有解析，似乎很不错。但是这个软件是基于大屏幕设计的，分辨率需要很高（1920x1080）才能清晰显示。而我的机器分辨率都比较低（穷，老笔记本 :( ）。所以体验一直很差，也就没怎么用。我把软件装在了虚拟机了，随便拉到哪台机器都能用，脱离了 license 的限制。有需要的同学可以跟我索取。 另外就是第二次考试前公司提供的托业官方的复习课程了（offical learning and preparation course）。这里要给公司的福利点赞。这个课程我做了大概一半的样子，之所以没有好好的做完，主要原因还是只有题目和答案，没有解析。有的时候做错了，也不知道错在哪里。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:5","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"附录 ","date":"2022-02-05","objectID":"/toeic_experience/:3:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"答题卡上的个人信息 EDUCATION BACKGROUND - Major en ch Liberal arts 人文学科，比如哲学 Social studies/law 社会学，法学 Accounting/business/economics/finance/marketing/trading 财务/金融/贸易… Sciences (agriculture, computer, mathematics, physic) 科学 Health (medicine, nursing, pharmacy, public health) 健康学 Engineering/architecture 工程架构 Other/none 其他 EDUCATION BACKGROUND - Dgree en ch Primary school 小学 Junior high school 初中 High school (Secondary school) 高中（中学） vocational/technical high school 职业/技术高中 3-Years college 3 年制大学 Community/Junior college (Associate degree) 社区/大专（副学士学位 Undergraduate/bacheior’s degree 本科/学士学位 Graduate/Master’s/doctoral degree 研究生/硕士/博士学位 Language institution 语言机构 Other 其他 ","date":"2022-02-05","objectID":"/toeic_experience/:3:1","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e/* 函数说明: 最多从源串中拷贝size－1个字符到目标串中，然后再在后面加一个0。所 以如果目标串的大小为size的话，将不会溢出。 函数返回值: 若成功则返回存入数组的字符数，若编码出错则返回负值。 */ int snprintf(char *str, size_t size, const char *format, ...); ","date":"2022-02-05","objectID":"/snprintf/:1:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"},{"categories":["programming"],"content":"用法分析 snprintf 和 sprintf 不同的是，当缓冲区不够用时，snprintf 会返回一个大于等于 n 的值，出错时返回一个负值。因此，当返回值是一个不大于 n-1 的非负值时，它可以保证缓冲区是以 NUL 结尾。 snprintf 的正确用法: #include \u003cstdio.h\u003e #define BUFSIZ 16 int main(int argc,char **argv) { char buf[BUFSIZ]; /* 注意这里长度不需要用sizeof(buf)-1，因为snprintf只会拷贝size-1个字节， * 并自己加上NULL结尾 */ snprintf(buf, sizeof(buf), \"%s\", argv[1]); return 0; } ","date":"2022-02-05","objectID":"/snprintf/:2:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"},{"categories":["programming"],"content":"注意事项 不管是 sprintf 还是 snprintf，在使用的时候必须注意被拷贝的字串于作为参数的字串不能相同，因为这会导致不可预知的返回值。例如： #include \u003cstdio.h\u003e int main(int argc, char **argv) { char str[16] = \"hello\"; snprintf(str, sizeof(str), \"%s-%d\", str, 1); printf(\"%s\\n\", str); return 0; } 参考 这份资料 If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results are undefined. ","date":"2022-02-05","objectID":"/snprintf/:3:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"}]