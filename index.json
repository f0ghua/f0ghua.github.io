[{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e /* 函数说明: 按照format指定的格式填充字符串str，以 '\\0' 结尾。 函数返回值: 若成功则返回存入数组的字符数，若编码出错则返回负值。 */ int sprintf(char *str, const char *format, ...); ","date":"2022-02-07","objectID":"/sprintf/:1:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"用法分析 sprintf 一般用来把其他类型的数据转换成字符数组储存。它会自动在所写入字符组的末尾加上 NUL 字符来表示字符串的结束，NUL 字符不被计入返回值。 sprintf 和 strcpy 一样，属于无边界检查的一类函数，不建议使用。 ","date":"2022-02-07","objectID":"/sprintf/:2:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"注意事项 对于新写的代码，请抛弃 sprintf，用 snprintf 代替。 ","date":"2022-02-07","objectID":"/sprintf/:3:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"函数原型 #include \u003cstring.h\u003e char *strcpy(char *dest, const char *src); ","date":"2022-02-07","objectID":"/strcpy/:1:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"用法分析 strcpy 属于无边界检查的一类函数，因此使用起来十分的危险，在标准文档中已经不建议使用。 无边界检查很容易就会发生缓冲溢出的错误，例如: #define BUFSIZ 265 int main(int argc, char **argv) { char buf[BUFSIZ]; strcpy(buf, argv[1]); return 0; } 注意这个例子中 buf 定义了大小为 256，但是 argv[1]却是不限制大小的。由于 strcpy 只知道拷贝到源字串结束，因此一旦 argv[1]的长度大于 BUFSIZ，就会引起缓冲溢出了。 ","date":"2022-02-07","objectID":"/strcpy/:2:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"注意事项 请抛弃 strcpy，用 strncpy 代替，最好用 strlcpy。 ","date":"2022-02-07","objectID":"/strcpy/:3:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"函数原型 #include \u003cstring.h\u003e char *strncpy(char *dest, const char *src, size_t n); ","date":"2022-02-07","objectID":"/strncpy/:1:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"用法分析 strncpy 由于添加了长度限制，避免了缓冲区溢出的问题。但在使用这个函数的时候必须要注意: strncpy 只有在源字符串的长度小于参数 n 时，它才会用 NUL(或者'\\0')来结束字符串。 因此正确的使用 strncpy 的方法是，当拷贝源字符串的一部分时，使用 strncpy 之后，自己手工添加 NUL 来结束字符串。 #define BUFSIZ 265 int main(int argc, char **argv) { char buf[BUFSIZ]; strncpy(buf, argv[1], sizeof(buf) - 1); buf[sizeof(buf) - 1] = '\\0'; /* 防止buf没有初始化为0，结束字符串 */ return 0; } 这里可以看到，要正确使用 strncpy 还是挺麻烦的一件事情。 ","date":"2022-02-07","objectID":"/strncpy/:2:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"注意事项 其实在 openbsd 里面提供了一个库函数 strlcpy 。它保证了目的字串总是以 NUL 结尾，并且返回值总是目的字串的全长(不包括 NUL)。其源码如下 /* $OpenBSD: strlcpy.c,v 1.11 2006/05/05 15:27:38 millert Exp $ */ /* * Copyright (c) 1998 Todd C. Miller \u003cTodd.Miller@courtesan.com\u003e * * Permission to use, copy, modify, and distribute this software for any * purpose with or without fee is hereby granted, provided that the above * copyright notice and this permission notice appear in all copies. * * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */ #include \u003csys/types.h\u003e#include \u003cstring.h\u003e /* * Copy src to string dst of size siz. At most siz-1 characters * will be copied. Always NUL terminates (unless siz == 0). * Returns strlen(src); if retval \u003e= siz, truncation occurred. */ size_t strlcpy(char *dst, const char *src, size_t siz) { char *d = dst; const char *s = src; size_t n = siz; /* Copy as many bytes as will fit */ if (n != 0) { while (--n != 0) { if ((*d++ = *s++) == '\\0') break; } } /* Not enough room in dst, add NUL and traverse rest of src */ if (n == 0) { if (siz != 0) *d = '\\0'; /* NUL-terminate dst */ while (*s++) ; } return(s - src - 1); /* count does not include NUL */ } ","date":"2022-02-07","objectID":"/strncpy/:3:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e int sscanf(const char *str, const char *format, ...); 这里 format 可以是一个或者多个 { %[*][width][{h|l|I64|L}]type | ' ' | '\\t' | '\\n' | 非%符号 } 其中 符号 说明 * 添加则表示满足条件的被过滤 width 表示宽度 h 表示单字节 l 表示双字节 L 表示 4 个字节 I64 表示 8 个字节 type 如 s, d 之类，表示字符串等 ","date":"2022-02-05","objectID":"/sscanf/:1:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"用法分析 ","date":"2022-02-05","objectID":"/sscanf/:2:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"基本用法 sscanf 一般用来从一个 ascii 字符串中读取一些值，基本用法很简单。例如 #include \u003cstdio.h\u003e int main () { char *str = \"121000-13:00:20\"; int s[6]; int i; sscanf(str,\"%2d%2d%2d-%d:%d:%d\", \u0026s[0],\u0026s[1],\u0026s[2],\u0026s[3],\u0026s[4],\u0026s[5]); for(i = 0;i \u003c 6;i++) printf(\"s[%d] = %d\\n\",i,s[i]); return 0; } ","date":"2022-02-05","objectID":"/sscanf/:2:1","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"高级用法 sscanf 提供了简单的模式匹配，其格式为 %[] 。 这里的 [ ] 和正则表达式中是一样的，表示匹配其中出现的字符序列。如果在 [ ] 中使用 ^ ，则是表示取反。 例如: [a-z] 表示小写字母序列,如abc ... [^a-z] 表示除小写字母的字符 举例来说明 #include \u003cstdio.h\u003e int main () { char *str = \"12:10:00-13:00:20\"; char s[6][3]; int i; sscanf(str,\"%[^:]:%[^:]:%[^-]-%[^:]:%[^:]:%[^:]\", s[0],s[1],s[2],s[3],s[4],s[5]); for(i = 0;i \u003c 6;i++) printf(\"s[%d] = %s\\n\",i,s[i]); return 0; } 这个例子分隔出了 str 字符串中的所有数字。其格式字符串分析如下： %[^:] 表示匹配不含 : 的字符串,所以第一个 %[^:] 就匹配了数字字符串 12 ,第二个则匹配了 10 ; 同理， %[^-] 表示匹配不含 - 的字符串,所以匹配字符串 13 ；其他的就不言而寓了。 还是上面的例子，如果我们把格式化字串变为 %[0-9]:%[0-9]:%[0-9]-%[0-9]:%[0-9]:%[0-9] , 将会如何？嘿嘿，一样的结果。因为 %[0-9] 就匹配了数字组成的字符串。 相信这一个例子应该足够说明问题，具体情况具体分析，主要还是靠大家活学活用了。 再举一个复杂点的例子，供参考： #include \u003cstdio.h\u003e /* 获取/和@之间的字符串 */ int main() { const char *s = \"iios/12DDWDFF@122\"; char buf[20]; sscanf(s, \"%*[^/]/%[^@]\", buf); printf(\"%s\\n\", buf); return 0; } ","date":"2022-02-05","objectID":"/sscanf/:2:2","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"注意事项 ","date":"2022-02-05","objectID":"/sscanf/:3:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"返回值检查 我们在使用 sscanf 的时候往往会忽略其返回值，事实上，sscanf 的返回值是很有用处的。 当匹配出错的时候其返回值为 EOF，否则返回匹配成功的参数个数，如够一个都没匹配到，就是 0 了。 举例子如下： int main(int argc, char **argv) { int i = 0, j = 0, r; r = sscanf(argv[1], \"%d:%d\", \u0026i, \u0026j); printf(\"r = %d, i = %d, j = %d\\n\", r, i, j); return 0; } 执行结果如下 $ ./main a r = 0, i = 0, j = 0 $ ./main 1 r = 1, i = 1, j = 0 $ ./main 1:2 r = 2, i = 1, j = 2 ","date":"2022-02-05","objectID":"/sscanf/:3:1","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"溢出问题 sscanf 最为人诟病的地方，是很容易出现缓冲区溢出错误。实际上 sscanf 是可以避免出现缓冲区溢出的，只要在书写任何字符串解析的格式时，注意加上其缓冲区尺寸的限制。如 #include \u003cstdio.h\u003e int main() { char match[8] = \"12345678\"; // fill with values to test with terminating // null character int len = sizeof(match)-1; const char *input = \"hello world\"; char format[16]; snprintf(format, sizeof(format), \"%%%d[a-z ]\", len); printf(\"format = %s\\n\", format); sscanf(input, format, match); printf(\"match = %s\\n\", match); } 输出为 format = %7[a-z ] match = hello w 这里 format 里面的 %7 就限定了拷贝过来的字符串长度为 7 ，也就是 match 的总长减一。 最后一个字符留给字符串的结尾字符 \\0 ，sscanf 会自动添加。 ","date":"2022-02-05","objectID":"/sscanf/:3:2","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["study"],"content":"概述 由于新公司的国外业务占比很高，因此要求托业要过 600 才行。所以入职后前后参加了 2 次考试，分别为 2021.8.24 和 2022.1.16 月份。第一次考了 560 分（250/310），第二次 730 分（350/380）。记录这份文件的目的主要是分享下考试经验，帮助跟我水平类似的人通过托业的考试。 第一次考试基本没做什么准备，只是考前熟悉了一下题型。而从第一次考试到第二次考试，期间虽然间隔了差不多 5 个月的时间，但真正用来复习的也就差不多最后一个多月。因为第二次考试其实是临时决定的，原本的计划是 2022 年后才开始备考。所以这个分享我觉得对于短时间备考的同学更有帮助一些。废话就不多说了，我们开始。 ","date":"2022-02-05","objectID":"/toeic_experience/:1:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"备考经验 ","date":"2022-02-05","objectID":"/toeic_experience/:2:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"原则 拿好你懂的分数，模糊的或者不懂的不要恋战。掌握好时间，题目最多过 2 遍，2遍了还不确定，直接猜，不要逗留 每一题都要当时就填，不懂就猜，不要留空，因为你后面没时间回头填 ","date":"2022-02-05","objectID":"/toeic_experience/:2:1","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"准备工作 考试前先准备好 2 支铅笔和橡皮。铅笔自己考前先试好，确认涂圆形的答题项顺滑。这点我认为很重要，因为如果削的太尖了，涂起来浪费时间，擦起来又不方便。 考试全程都是播放的录音指导考试过程，全英文，建议没考过的同学先做下模拟题熟悉一下旁白的内容。这样你可以知道，哪些时间是你可以利用起来看题或者休息。 进入考场后，桌子上会放有写有准考证号的纸条和你的答题卡。答题卡上的正面以及反面的上半部分都是一些个人信息以及托业官方的调查信息，然后才是题目答案。考前，会有专门的时间（大约 15 分钟）录音指导一步步的填写除答题以外的部分。但是我建议可以乘等待的时间先把答题卡填起来，因为答题卡上有一项需要抄写声明，对于书写慢的同学来说还是有点紧的，为不影响考试情绪，建议提前写好。这时候监考老师一般是不会管的。虽然第一次考试的时候，老师说先不要填写，但是填了也没关系。 我参加的 2 次考试，一次在公司，一次是在外面（托业指定的社会考试地点，某旅店的宴会厅）。考试环境都很安静，基本不会出现一些人提到的外界声音干扰什么的问题，所以这点不用担心。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:2","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"时间分配 托业题量很大，如果不熟悉，根本是来不及做完的。比如我第一次，就整整留下来 5 大题的阅读没有完成。而第二次，经过了练习以后也还是省下了最后 3 道选择题没看，结果是乱填的。所以时间分配很重要。 总时间是 120 分钟，其中 45 分钟听力，75 分钟阅读。 听力 听力其实没什么好说的，因为都是一题一题的过，需要注意的是以下几点关于网上介绍的考试技巧的体会 利用旁白的时间先看看后面要做的题目，比如图片题的图片，短文问答题的问题以及答案。因为旁白的时间一般都比较长，浪费了有点可惜，看看后面的内容也无妨，但是不要抱多大期待。因为对我这样的英文基础，其实看不看影响真的不大。听力好的同学不妨使用。 利用上一题剩下的时间预先审下一题。这个对我来说就太难了，实际操作下来基本没啥用处，做完上一题，基本不剩几秒了，看一下题太过勉强，别费那个心了。(人家的操作是在听短文的时候顺便就把问题做完了，短文结束读问题的时候就跳到下一题去看问题了。我根本做不到听短文的时候还去答问题，一分心短文都听不完整了) 阅读 阅读的 75 分钟时间，建议这样分配，在练习中就通过倒计时来熟悉。 大题 题型 题数 时间 5 句子填空 30 (101~130) 10 分钟 (20 秒一题) 6 短文填空 16 (131~146) 5 分钟 7 单篇阅读(10 篇) 29（147~175） 30 分钟 (3 分钟一篇) 7 多篇阅读(5 篇) 25 (176~200) 30 分钟（5 分钟一篇） ","date":"2022-02-05","objectID":"/toeic_experience/:2:3","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"其他 词汇量 词汇量不是一个月两个月就能提高的。但是对于托业来说，我觉得最好的方式是刷题，然后从题目中记录单词。只是针对这些生词来记忆，可以短期内提高托业的成绩。 听力 说实话，两次考试，我自我觉得听力其实没多少提高，这个确实是硬实力，需要不断的磨耳朵才行。听力上我的建议是针对 Part1 和 Part2 多练习，因为这两项是可以在短期内提高的，而 Part3 和 Part4，有时间就多练多听，没时间。。。就蒙吧，反正我第二次考试 Part3 和 Part4 真正听懂的很少。 另外几个相关的技巧供参考 有的同学记忆不好，比如听到了 A 不确定，听到了 C 又不确定，到听完 D 的时候忘记了 B 是对的还是错的了，猜题的时候就不知道该猜哪个了。考题本和答题卡上都不能做记号，这里有个办法，就是用手指来表示 ABCD，比如左手大拇指表示 A，食指表示 B，依次类推。每一题读完，就用手指的状态表示是否错误。比如如果 A 确定是错的，那么就把大拇指弯曲，B不确定那就保持直着，C错误那就弯曲中指，最后 D 也不确定，那就 BD 里面猜。 对于 Part2 ，关键就是在于听清楚第一个词，4W1H，即 What， Who，Where，When 以及 How 。听清楚了这 4 个词就有 80% 以上的机会答对了。 阅读 单句填空主要是考 单词/文法/词性，所以先知道考点很重要。建议先看答案，再看题。这样有的题目可能马上就能知道答案了，甚至都不需要知道单词是什么意思。这点刷题后自然会有体会。 单篇阅读和多篇阅读也是建议先看题再到文章中去找答案。这样感觉还是要快很多。平时练习可以看一下自己的速度，如果来不及，那么就放弃那些需要看全篇才能找答案的题目。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:4","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"备考资料 先说重点，备考资料里我觉得最有用的就是书和 abceed。 书 \r 2021 新托业模拟题库 我只买了这一套。并且只做了 Part5-Part7 的那两本。前面的听力部分我都是靠手机端软件 abceed 来熟悉。 移动端 \r 背单词：不背单词 + Anki 我背单词的主力软件是不背单词，所有从托业刷题过来的生词都加到生词本，然后每天早上花半小时左右时间复习。 Anki 作为不背单词的补充。因为不背单词有些生词会找不到，所以需要手动记录到 Anki 上进行记忆。当然，托业中遇到的语法，词组等等也都可以记录在 Anki 上。 \r 刷题：abceed + QuizFun 考尚乐 首先我用的是 iphone，这两个软件都需要美区账户才能下载。 abceed 是一个日本人写的软件，可以说是托业最好的移动端软件了，缺点是收费和具体说明文字为日文。软件可以定目标，随时刷题，并即时调整你的成绩。充分的利用碎片时间熟悉题型。我觉得对于听力部分的练习很有用处。而阅读的部分，由于我用的是手机，往往看文章的时候由于显示不全得翻页，严重影响了体验，所以阅读部分对我的帮助应该主要还是在于熟悉题型和收集生词。用 ipad 应该会好很多。建议如果基础不太好的同学花 3 个月左右的时间备考，可以买 3 个月，大概人民币 400 不到，比单月买的便宜很多。 考尚乐 则是台湾人做的一个软件，在台湾托业叫做多益，所以搜考题的时候直接搜多益就可以了。这个软件也是收费的，但是有一些免费的可以用来练习。这个软件我是后来才知道的，所以只是作为一个补充使用。它比 abceed 好的地方在于都是中文解析，不好的地方在于题目有些老，感觉难度相比实际考试偏高。 电脑端 我第一次考试前在淘宝买了一个托业的软件，可以做模拟试题。大概 10 几套试卷，而且每个都有解析，似乎很不错。但是这个软件是基于大屏幕设计的，分辨率需要很高（1920x1080）才能清晰显示。而我的机器分辨率都比较低（穷，老笔记本 :( ）。所以体验一直很差，也就没怎么用。我把软件装在了虚拟机了，随便拉到哪台机器都能用，脱离了 license 的限制。有需要的同学可以跟我索取。 另外就是第二次考试前公司提供的托业官方的复习课程了（offical learning and preparation course）。这里要给公司的福利点赞。这个课程我做了大概一半的样子，之所以没有好好的做完，主要原因还是只有题目和答案，没有解析。有的时候做错了，也不知道错在哪里。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:5","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"附录 ","date":"2022-02-05","objectID":"/toeic_experience/:3:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"答题卡上的个人信息 EDUCATION BACKGROUND - Major en ch Liberal arts 人文学科，比如哲学 Social studies/law 社会学，法学 Accounting/business/economics/finance/marketing/trading 财务/金融/贸易… Sciences (agriculture, computer, mathematics, physic) 科学 Health (medicine, nursing, pharmacy, public health) 健康学 Engineering/architecture 工程架构 Other/none 其他 EDUCATION BACKGROUND - Dgree en ch Primary school 小学 Junior high school 初中 High school (Secondary school) 高中（中学） vocational/technical high school 职业/技术高中 3-Years college 3 年制大学 Community/Junior college (Associate degree) 社区/大专（副学士学位 Undergraduate/bacheior’s degree 本科/学士学位 Graduate/Master’s/doctoral degree 研究生/硕士/博士学位 Language institution 语言机构 Other 其他 ","date":"2022-02-05","objectID":"/toeic_experience/:3:1","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e/* 函数说明: 最多从源串中拷贝size－1个字符到目标串中，然后再在后面加一个0。所 以如果目标串的大小为size的话，将不会溢出。 函数返回值: 若成功则返回存入数组的字符数，若编码出错则返回负值。 */ int snprintf(char *str, size_t size, const char *format, ...); ","date":"2022-02-05","objectID":"/snprintf/:1:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"},{"categories":["programming"],"content":"用法分析 snprintf 和 sprintf 不同的是，当缓冲区不够用时，snprintf 会返回一个大于等于 n 的值，出错时返回一个负值。因此，当返回值是一个不大于 n-1 的非负值时，它可以保证缓冲区是以 NUL 结尾。 snprintf 的正确用法: #include \u003cstdio.h\u003e #define BUFSIZ 16 int main(int argc,char **argv) { char buf[BUFSIZ]; /* 注意这里长度不需要用sizeof(buf)-1，因为snprintf只会拷贝size-1个字节， * 并自己加上NULL结尾 */ snprintf(buf, sizeof(buf), \"%s\", argv[1]); return 0; } ","date":"2022-02-05","objectID":"/snprintf/:2:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"},{"categories":["programming"],"content":"注意事项 不管是 sprintf 还是 snprintf，在使用的时候必须注意被拷贝的字串于作为参数的字串不能相同，因为这会导致不可预知的返回值。例如： #include \u003cstdio.h\u003e int main(int argc, char **argv) { char str[16] = \"hello\"; snprintf(str, sizeof(str), \"%s-%d\", str, 1); printf(\"%s\\n\", str); return 0; } 参考 这份资料 If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results are undefined. ","date":"2022-02-05","objectID":"/snprintf/:3:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"}]