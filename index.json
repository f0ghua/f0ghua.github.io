[{"categories":null,"content":"本来是想写一篇 IPv6 的文档，可以帮助不熟悉 IPv6 的同事快速了解 IPv6。但是后来发现越写越庞大，太过细节，重复了很多 IPv6 书籍中的内容，从而偏离了原本的目的。所以最终还是决定以 FAQ 的形式提供速查。 ","date":"2023-09-11","objectID":"/ipv6_faq/:0:0","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"FAQs ","date":"2023-09-11","objectID":"/ipv6_faq/:1:0","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: IPv6 的地址如何表示？ IPv6 的地址使用 128 bits 表示，每 16 bits 为一组，用冒号分隔，分成 8 组，如 2001:0db8:0000:0000:0001:0002:0003:0004 为了便于输入和记忆，我们可以将之简化 去除每组前面的 0，上面的地址变为: 2001:db8:0:0:1:2:3:4 如果是连续的多组 0，那么可以直接简化为 :: ，地址变为： 2001:db8::1:2:3:4 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:1","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: 为什么显示的 IPv6 地址后面有 /64 ? 一个 IPv6 的地址，可以分为网络地址和主机地址 2 个部分。通过网络前缀可以指定网络地址所占用的位数。如果要表示一个 IPv6 的网络前缀（表示一个网段），可以用 ipv6地址/前缀长度 的格式。如： 2001:db8::1:2:3:4/64 表示地址的前 64 bits（ 2001:db8:: ）为网络地址，其余的（ 1:2:3:4 ）为主机地址。 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:2","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: 为什么我的网卡上会显示多个 IPv6 地址？ 一个接口可以拥有多个 IPv6 的地址，在 RFC4291 中定义了不同 IPv6 地址的用途和地址范围。 从类型上来说，IPv6 地址主要分为单播（unicast），多播（multicast）， anycast（RFC1546）等几种。anycast 地址很少涉及，所以这里不予讨论。 单播（unicast） 单播地址可以细分为以下几种（这里用 IPv4 做对比，便于理解其用途） Scope RFC Prefix IPv4 equivalent Link Local 4291 fe80::/10 169.254.0.0/16 Unique Local 4193 fc00::/8 fd00::/8 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 Global 4291 2000:/3 class A,B,C except private Loopback 4291 ::1/128 127.0.0.1 Unspecified 4291 ::/128 0.0.0.0 \r 链路本地地址（LLA - Link Local Address） 由前缀 fe80::/10 指定 环回地址（ ::1 ）作为一个特殊的链路本地地址，相当于 IPv4 的 127.0.0.1 链路本地地址只在接口所连接的本地网络链路上有效 \r 唯一本地地址（ULA - Unique Local Address） 这就是我们通常所说的私网地址。只在本地局域网内有效，其跟 LLA 的区别在于 ULA 可以跨路由器，而 LLA 不可以。 唯一本地地址（ULA）由前缀 fc00::/7 指定。可以分为 fc00::/8 和 fd00::/8 两个 block 。 RFC 4193 定义了 ULA 的地址格式如下 | 7 bits |1| 40 bits | 16 bits | 64 bits | +--------+-+------------+-----------+----------------------------+ | Prefix |L| Global ID | Subnet ID | Interface ID | +--------+-+------------+-----------+----------------------------+ 其中 L 0 作为预留不适用，所以该值总是为 1。也就是说有效的前缀值目前只有 fd00::/8 Global ID 这是一个 40 bits 的伪随机值，保证了每次生成的都是一个唯一值。之所以添加这个字段，是为了让 ULA 具备 GUA 的唯一性属性，从而在不同网络进行合并的时候可以避免地址前缀冲突的问题。 更多的信息可以参考以下几份资料 Getting IPv6 private addressing right \r 全球单播地址（GUA - Global Unicast Address） 这就是我们通常所说的公网地址。它的有效范围是全球网络。 多播（multicast） 在 IPv6 中没有广播地址，所以对于需要发送给多个接收端的封包，使用了多播地址（有的文献里也会翻译成组播）。 多播地址的地址范围定义则如下所示： Type RFC Prefix IPv4 equivalent Multicast 4291 ff00::/8 224.0.0.0/4 常用的多播地址如下表所示 Address Description ff01::1 All nodes in the interface-local ff02::1 All nodes in the link-local ff01::2 All routers in the interface-local ff02::2 All routers in the link-local 地址 ff01::1 的说明可能比较难理解，关键在于 interface-local ，指的是接口本地范围。 RFC4297 中对此的说明如下 Interface-Local scope spans only a single interface on a node and is useful only for loopback transmission of multicast. 简单来讲，ff01::1 只用于本地还回地址的多播。当 lo interface 起来的时候会加入该多播组。 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:3","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: Linux 使用 ip 命令查看的时候可以看到每个 IPv6 地址后面都有 lifetime，这是什么意思 ？ 对于每一个 IPv6 地址来说，有两个 Lifetime。这两个时间在接口获得 ip 的时候就开始倒计时。 preferred-lifetime 首选生存期。表示前缀可用的时间范围。在此范围内，前缀地址可以作为源地址或者目的地址自由使用。当生存期倒计时归零，则地址变的不可用（除了之前开始尚未结束的相关事务） valid-lifetime 前缀在不可用之前保持可用的总时间。首选生存期到期后，任何自动配置的地址都将被弃用，并且仅用于在首选生存期到期之前开始的事务。如果有效生存期也过期，则地址将变得完全不可用。 因此，随着这两个 lifetime 的变化，IPv6 地址也会表现为不同的状态，如下图所示 ┌────────────┬────────────────────┬────────────────────┬───────────────────┐ │ │ │ │ │ │ DAD │ preferred │ deprecated │ invalid │ │ │ │ │ │ ────┴────────────┴────────────────────┴────────────────────┴───────────────────┴──► ┼ invalid ┼ valid ┼ invalid ┼ ┼ new connection ┼ old connection ┼ │ preferred lft out │ ─────────────────┼────────────────────┴────────────────────┬──────────────────────► │ deprecated lft out │ 这些地址状态在 RFC4862 中定义，简单描述则如下所示 preferred 新连接使用的地址。当 preferred lifetime 过期则地址变成 deprecated deprecated 旧连接使用的地址。当 valid lifetime 过期则地址变成 invalid valid 有效地址。包括 preferred address 和 deprecated address invalid 无效地址 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:4","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: 一个接口上的 IPv6 地址是如何产生的？ 简单的说，链路本地地址（LLA）和环回地址由系统自身生成；而唯一本地地址（ULA）和全球单播地址（GUA）则是由服务器分配而来。这里说的服务器，提供的可以是路由器的 radvd 服务，也可以是 dhcpv6 服务。 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:5","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: 链路本地地址（LLA）是如何生成的？ 链路本地地址由本机独立产生，不依赖于外部环境。产生的过程大致如下： 获取网卡的 MAC 地址，如 00:e0:81:2e:b6:d1 反转第一字节的第二比特： 02:e0:81:2e:b6:d1 在中间插入 2 字节 FFFE ，扩展到 MAC 地址到 64 位 : 02:e0:81:FF:FE:2e:b6:d1 加上 LLA 的前缀 fe80::/64 : fe80::2e0:81FF:FE2e:b6d1 前面三步从 48 位的 MAC 转换成 64 位主机地址的过程称为 EUI64。 需要注意的是，该地址产生之后，还需要使用 NDP（Network Discovery Protocol）协议，向本地链路发送 NS 包，执行 DAD 检测，检查是否该地址已经被占用。如果有人回复 NA，那就说明有冲突，需要人工校正。 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:6","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"什么是网络发现协议（ NDP - Network Discovery Protocol）？ 网络发现协议（NDP）定义在 RFC4861 中，主要包含了 2 部分的内容。 NS, NA RS, RA 邻居发现协议 邻居发现协议主要用来查询 IPv6 地址对应的主机的 MAC 地址。使用到了两种类型的封包，即 NS 和 NA。 一个正常的 NS， NA 交互如图所示 ns_nans_na \" ns_na 完整的封包可以 在线查看 ，也可以从以下链接下载 ipv6_faq.file.ns_na.pcap 要查看 NDP 的解析结果，Linux 下可以通过以下命令查看 ip -6 neighbor show 输出为 fe80::200:ff:feaa:2 dev eth0 lladdr 00:00:00:aa:00:02 router STALE 该命令类似 ipv4 的 arp -a 路由发现协议 路由发现协议则是主机用来查找网络中的路由器（网关）。主要使用的封包类型为 RS 和 RA。 当路由启用了 radvd 服务，那么每次启动后就会向本地链路网络周期性的发送 RA 封包。主机也可以通过主动发送 RS 封包查询 RA。 通过路由发现协议，主机可以从 RA 包中获取到主机的 IPv6 地址前缀，默认路由的网关地址，以及 DNS 地址（RFC6106）。这样，正常上网所需要的要素就齐全了。 当主机接收到 RA 报文的时候，应该根据报文中的内容添加或者删除路由。具体的规则参考 RFC4191 。 如何添加路由主要看两个地方 一个是在 RA 报文的 Flags 中的 Default Router Preference 字段和 Router\rlifetime 。当 Lifetime 不为 0 的时候，添加默认路由；为 0 时表示删除该路由。观察 ipv6-router-advertisement-leaving.pcapng 的 packet 1 和 packet 2。主机接收到第一个 RA 的时候就会添加路由，而接受到第二个的时候则会删除默认路由。 另一个是看 Route Information Option，这个里面也有 Preference 和 Lifetime。用法同上，但是优先级要高于前者。两者的区别在于前者只用来管理默认路由，而 Option 大多用来添加某特定前缀的路由 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:7","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: ULA 和 GUA 是如何获取的？ IPv6 地址的获取方式可以分为 2 种。一个是 SLAAC，还有一个是 DHCPv6。 SLAAC 协议的具体描述在 RFC4862 中。利用 NDP 中定义的 RA 报文，给主机提供了前缀，路由，默认网关等信息，从而保证了在网络中没有其他服务器的情况，主机可以获取到 IPv6 地址并正常的访问外部网络。 需要注意的是 RFC4862 只考虑了 IP 地址的分配问题，没有考虑到 DNS 的部分。所以按照 RFC4862 实现的 SLAAC，主机是不能正常解析域名的。基于此，又出了一份 RFC6106，给 SLAAC 添加了 DNS 的支持。 DHCPv6 由 RFC8415 定义。实现类似 DHCPv4，就不展开说明了。 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:8","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: SLAAC 是怎么工作的？ SLAAC 的过程大致分为两个阶段： 生成链路本地地址（LLA） 使用 Network Discovery 协议生成全球单播地址（GUA） 链路本地地址的生成过程在前面已经讲过，这里直接看主机怎么通过 NDP 获取 GUA 的。 对于支持 SLAAC 的网络，网关会定时发送 RA，提供 Prefix 给网络中的主机使用。而每台主机在适当的时机（比如网卡 UP）也会发送 RS 去主动查询。当主机获取到 RA 中包含的 Prefix 后，就可以通过 EUI64 的方式生成 GUA 了。 一个普通的 RA 包的内容如图所示 rara \" ra 完整的封包可以 在线查看 ，也可以从以下链接下载 ipv6_faq.file.ra.pcap 可以看到这个 RA 包发送给 link local 上的所有主机，提供了前缀 2401:4900:d00:ffff::/64 ，默认网关自己（Lifetime \u003e 0），DNS Server 两个 2401:4900::10 和 2401:4900::11 通过这两个阶段，主机就能自动的获取到 IPv6 的 GUA 地址和 Gateway 地址。但是要正常跟外界沟通解析 DNS，还需要 DNS Server 等信息。因此 RFC6106 又给 RA 包中增加了 RDNSS 选项。这样，只需要 SLAAC 就能提供主机和外界交流所需要的全部功能了。 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:9","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: 什么是 DHCPv6 Stateless 和 DHCPv6 Stateful? 所谓的 Stateless 和 Stateful 是针对 IPv6 地址而言。有状态（Stateful）表示 IPv6 地址的管理（租赁和回收等）由特定的服务完成，这里的服务就是 DHCPv6 Server；而无状态（Stateless）顾名思义就是 IPv6 地址由主机自己生成，DHCPv6 不参与管理。 那么我们都知道 DHCPv6 服务就是用来分配 IP 地址的，搞这么个 Stateless 模式出来又不分配 IP 有什么用呢？这就要回到前面提到过的 SLAAC 模式了。SLAAC 在最初设计的时候并没有 DNS 相关的 option，所以也就无法给主机分配 DNS Server。为了弥补这个缺失，就使用了 DHCPv6 Stateless 来提供相关信息。此时 SLAAC 负责分配 IP，而 DHCPv6 负责提供其他的信息（通过 Information-Request）。 知道了工作机制，再来看一下对应的封包。 DHCPv6 Stateful 的封包如下 dhcpv6_pddhcpv6_pd \" dhcpv6_pd 完整的封包可以 在线查看 ，也可以从以下链接下载 ipv6_faq.file.dhcpv6_pd.pcap DHCPv6 Stateless 的封包如下： dhcpv6_stateless_no_pddhcpv6_stateless_no_pd \" dhcpv6_stateless_no_pd 完整的封包可以 在线查看 ，也可以从以下链接下载 ipv6_faq.file.dhcpv6_stateless_no_pd.pcap 这里需要注意的是，如果 DHCPv6 Stateless 需要获取 PD 的话，那么就不是发送 Information-Request 而是要发送 Solicit 的了。此时的封包应该如下所示： dhcpv6_stateless_pddhcpv6_stateless_pd \" dhcpv6_stateless_pd 完整的封包可以 在线查看 ，也可以从以下链接下载 ipv6_faq.file.dhcpv6_stateless_pd.pcap ","date":"2023-09-11","objectID":"/ipv6_faq/:1:10","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: SLAAC 和 DHCPv6 是如何协同工作的？ IPv6 允许 SLAAC 和 DHCPv6 同时存在。两者可以并列运行也可以互相配合。 那么主机怎么知道应该通过哪种方式进行呢？这就要说到 RA 包中的 3 个关键 flag 了。 ra_flagsra_flags \" ra_flags Autonomous flag（简称 A flag）：表示是否配置无状态 IP。在一个 RA 报文中，可存在多个 prefix，比如 2401::/64、2402::/64、2403::/64，每个 prefix 都可以独立配置 A flag 为 on 时（对应 bit 位为 1）：表示客户端应当在该 prefix 范围内自动生成 IPv6 地址（客户端通过 DAD 自行保证地址可用），并配置子网路由条目、网关 为 off 时（对应 bit 位为 0）：表示客户端不应当在该 prefix 范围内自动生成 IPv6 地址，但是可以配置子网路由条目、网关 Managed flag（简称 M flag）：表示是否配置有状态 IP。M flag 是 RA 报文的全局参数，一个 RA 报文只有一个 M flag 为 on 时（对应 bit 位为 1）：表示在 SLAAC 流程结束后开始 DHCPv6 stateful 流程，也就是告诉客户端可以通过 DHCPv6 来获得 IPv6 地址和其他参数（如 DNS 列表） 为 off 时（对应 bit 位为 0）：表示不通过 DHCPv6 来获得 IPv6 地址 Other flag（简称 O flag）：表示是否通过 DHCPv6 获得除 IP 以外的其他参数（如 DNS 列表）。 O flag 也是 RA 报文中的全局参数，一个 RA 报文只有一个 O flag。 注意：仅当 M flag 为 off 时，该参数才会被读取。 为 on 时（对应 bit 位为 1）：当 M flag 为 on，或者 M flag 为 off 且至少有一个 A flag 为 on 时，将通过 DHCPv6 获得其他参数 为 off 时（对应 bit 位为 0）：当 M flag 为 on 时，依然将通过 DHCPv6 获得其他参数；当 M flag 也为 off 时，将不通过 DHCPv6 获得其他参数 各 flag 的组合功能可以用下表说明 Flag RA IP DHCPv6 IP DHCPv6 DNS M=1, O=1, A=1 Y Y Y M=1, O=1, A=0 N Y Y M=1, O=0, A=1 Y Y Y M=1, O=0, A=0 N Y Y M=0, O=1, A=1 Y N Y M=0, O=1, A=0 N N Y M=0, O=0, A=1 Y N N M=0, O=0, A=0 N N N 无状态和有状态并不是相互对立的，他们可以同时存在，也就是一张网卡上可以同时出现通过 RA 生成的 IP 以及通过 DHCPv6 获得的 IP。 主机获取 IP 的过程可以用以下流程图来帮助理解 ─┬─ ┌─────────────────────┐ │ │ generate link local │ │ │ address │ │ └──────────┬──────────┘ │ │ │ │ │ ┌──────────▼──────────┐ │ │ send RS, wait for RA│ │ │ from a gateway │ │ └──────────┬──────────┘ │ │ │ │ │ ┌──────────▼──────────┐ │ │ RA is received? ├────────────────────────────────┐ │ │ │ N │ │ └──────────┬──────────┘ │ │ │ Y │ │ │ │ │ ┌──────────▼──────────┐ │ │ get prefix in RA │ │ SLAAC │ │ │ └──────────┬──────────┘ │ │ │ │ │ │ │ │ ┌──────────▼──────────┐ │ │ │ A flag is set? ├─────────────────┐ │ │ │ │ N │ │ │ └──────────┬──────────┘ │ │ │ │ Y │ │ │ │ │ │ │ ┌──────────▼──────────┐ ┌──────────▼──────────┐ │ │ │ generate IP, route, │ │ generate only route │ │ │ │ gateway │ │ and gateway │ │ │ └──────────┬──────────┘ └──────────┬──────────┘ │ │ │ │ │ │ │ │ │ │ ◄────────────────────────────┘ │ │ │ │ │ │ │ │ ┌──────────▼──────────┐ ┌─────────────────────┐ │ ─┼─ │ M flag is set? ├──────► O flag is set? ├───┤ │ │ │ N │ │ N │ │ └──────────┬──────────┘ └──────────┬──────────┘ │ │ │ Y │ Y │ │ │ │ │ ┌──────────▼──────────┐ ┌──────────▼──────────┐ │ DHCPv6 │ use DHCPv6 get IP │ │ use DHCP get other │ │ │ and other options │ │ options │ │ │ └──────────┬──────────┘ └──────────┬──────────┘ │ │ │ │ │ │ │ │ │ ─┴─ ◄────────────────────────────┴──────────────┘ │ │ ▼ ","date":"2023-09-11","objectID":"/ipv6_faq/:1:11","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: OpenWRT 中是如何通过配置项实现 IPv6 各种获取 IP 的方式的？ OpenWRT 跟获取 IPv6 地址相关的参数最主要的有 2 个 reqaddress 是否通过 DHCPv6 获取 IP reqprefix DHCPv6 是否请求 IA_PD network.wan6.reqaddress GUI/Request IPv6-address none disabled try try force force network.wan6.reqprefix GUI/Request IPv6-prefix of length auto Automatic no disabled int value(64, 60…) int value(64, 60…) reqaddress reqprefix Method none disabled SLAAC + DHCPv6 stateless (information-request) none auto/int SLAAC + DHCPv6 stateless (PD in solicit) try disabled SLAAC + DHCPv6 stateful (no PD in solicit) try auto/int SLAAC + DHCPv6 stateful (PD in solicit) force disabled SLAAC + DHCPv6 stateful (no PD in solicit) force auto/int SLAAC + DHCPv6 stateful (PD in solicit) force 和 try 的区别在于，如果 DHCPv6 server 不支持 IA_NA，那么 force 会保持 DHCPv6 stateful 模式，然后失败重发 solicit；而 try 会自动切换成 DHCPv6 stateless 模式 ","date":"2023-09-11","objectID":"/ipv6_faq/:1:12","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Q: 如何使用 wireshark 过滤 slaac 和 dhcpv6 的封包？ # 过滤 NS NA icmpv6.type==135 || icmpv6.type == 136 # 过滤指定设备间的 RS RA, dhcpv6 ((icmpv6.type == 133 || icmpv6.type == 134 || dhcpv6) \u0026\u0026 (eth.addr == \u003cclient_mac\u003e || eth.addr == \u003cserver_mac\u003e)) ","date":"2023-09-11","objectID":"/ipv6_faq/:1:13","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"Appendix ","date":"2023-09-11","objectID":"/ipv6_faq/:2:0","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"IPv6 RFCs 本文中提及的 RFC 列表如下 RFC No. RFC Title 4191 Default Router Preferences and More-Specific Routes 4861 Neighbor Discovery for IP version 6 (IPv6) 4862 IPv6 Stateless Address Autoconfiguration 6106 IPv6 Router Advertisement Options for DNS Configuration 8415 Dynamic Host Configuration Protocol for IPv6 (DHCPv6) 更全的 IPv6 相关 RFC 可以参考一下链接 Key IPv6 Addressing RFCs ","date":"2023-09-11","objectID":"/ipv6_faq/:2:1","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"References Understanding IPv6 IOS DHCPv6 deployment schemes 彻底弄明白有状态与无状态配置IPv6地址 IPv6 Subnet Calculator ","date":"2023-09-11","objectID":"/ipv6_faq/:2:2","tags":null,"title":"IPv6 FAQ","uri":"/ipv6_faq/"},{"categories":null,"content":"LUCI 安装 $ ./scripts/feeds update packages luci $ ./scripts/feeds install -a -p luci $ make menuconfig LUCI Collections luci ","date":"2022-08-04","objectID":"/openwrt-luci/:1:0","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"LUCI 的工作原理 首先说明，这里分析的版本为 openwrt-21.02.3 LUCI 可以理解为 lua + UCI 。是用 lua 实现的读写 UCI 配置的一个框架。这个框架配合 uhttpd 可以实现简单快速的页面开发和访问配置。 在 openwrt 中，默认 uhttpd 的启动参数如下 /usr/sbin/uhttpd -f -h /www -r OpenWrt -x /cgi-bin -u /ubus -t 60 -T 30 -k 20 -A 1 -n 3 -N 100 -R -p 0.0.0.0:80 -p [::]:80 ","date":"2022-08-04","objectID":"/openwrt-luci/:2:0","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"页面显示 以访问主页面为例。访问的页面为 http://192.168.1.1/ ，此时访问的是 uhttpd 提供的 80 端口开放的服务。 查看 uhttpd 的配置文件 /etc/config/uhttpd 可以知道 root@OpenWrt:/# cat /etc/config/uhttpd config uhttpd 'main' list listen_http '0.0.0.0:80' list listen_http '[::]:80' list listen_https '0.0.0.0:443' list listen_https '[::]:443' option redirect_https '0' option home '/www' option rfc1918_filter '1' option max_requests '3' option max_connections '100' option cert '/etc/uhttpd.crt' option key '/etc/uhttpd.key' option cgi_prefix '/cgi-bin' list lua_prefix '/cgi-bin/luci=/usr/lib/lua/luci/sgi/uhttpd.lua' option script_timeout '60' option network_timeout '30' option http_keepalive '20' option tcp_keepalive '1' option ubus_prefix '/ubus' config cert 'defaults' option days '730' option key_type 'ec' option bits '2048' option ec_curve 'P-256' option country 'ZZ' option state 'Somewhere' option location 'Unknown' option commonname 'OpenWrt' 默认读取的应该是 /www （home 目录）下的 index.html 文件。该文件包含以下语句 \u003cmeta http-equiv=\"refresh\" content=\"0; URL=cgi-bin/luci/\" /\u003e 所以会被自动导向 /cgi-bin/luci/ 。而从 /etc/config/uhttpd 文件中的 list\rlua_prefix 设置可以知道当解析到 url 字串为 /cgi-bin/luci 的时候会转给 lua 脚本 /usr/lib/lua/luci/sgi/uhttpd.lua 来处理。 看看里面的主要内容 require \"luci.dispatcher\" function handle_request(env) local x = coroutine.create(luci.dispatcher.httpdispatch) 可以看到在获得 http 的 request 之后又转给 /usr/lib/lua/luci/dispatcher.lua 里面的 httpdispatch 函数处理去了，最终执行的是函数 dispatch 。 function httpdispatch(request, prefix) local stat, err = util.coxpcall(function() dispatch(context.request) end, error500) function dispatch(request) local menu = menu_json() local page = menu -- 分析 /usr/share/luci/menu.d/*.json 文件，获得页面的节点树 if action.type == \"view\" then elseif action.type == \"call\" then elseif action.type == \"firstchild\" then -- ... -- 根据节点里面的action属性做相应的处理 dispatch 函数会先根据目录 /usr/share/luci/menu.d/ 下的内容产生节点树，然后由带进来的 request 找到对应的节点，根据 action.type 再作相应的处理，将请求的页面返回给客户端浏览器。 由于 action.type 为 view 和 firstchild 的情形比较典型，所以这里只分析这两种的处理过程。理解了这两种，其他的也就很容易看懂了。 action.type == view 先来看看 action.type == view 的情况 。比如访问路径为 http://192.168.1.111/cgi-bin/luci/admin/system ，在文件 /usr/share/luci/menu.d/luci-mod-system.json 中定义的路径如下: \"admin/system/system\": { \"title\": \"System\", \"order\": 1, \"action\": { \"type\": \"view\", \"path\": \"system/system\" }, \"depends\": { \"acl\": [ \"luci-mod-system-config\" ] } }, 当访问该页面时（ 菜单 System-\u003eSystem ），lua 脚本的调试输出如下（调试的方法见后面章节）： root@OpenWrt:/usr/lib/lua/luci# :\u003e/tmp/luci.output \u0026\u0026 tail -f /tmp/luci.output [09:48:00]: dispatcher.lua httpdispatch enter, pathinfo = /admin/system/system [09:48:00]: dispatch enter [09:48:00]: init_template_engine enter, media = /luci-static/bootstrap [09:48:00]: Template.__init__ enter, name = themes/bootstrap/header [09:48:00]: sourcefile =/usr/lib/lua/luci/view/themes/bootstrap/header.htm [09:48:00]: Template.__init__ exit [09:48:00]: init_template_engine after Template themes/bootstrap/header [09:48:00]: init_template_engine exit [09:48:00]: dispatch action = { type = 'view' path = 'system/system' } [09:48:00]: Template.__init__ enter, name = view [09:48:00]: sourcefile =/usr/lib/lua/luci/view/view.htm [09:48:00]: Template.__init__ exit [09:48:00]: Template.render enter, scope = { view = 'system/system' } [09:48:00]: Template.__init__ enter, name = header [09:48:00]: sourcefile =/usr/lib/lua/luci/view/header.htm [09:48:00]: Template.__init__ exit [09:48:00]: Template.render enter, scope = { } [09:48:00]: Template.__init__ enter, name = themes/bootstrap/header [09:48:00]: Template.__init__ exit [09:48:00]: Template.render enter, scope = { } [09:48:00]: Template.render exit [09:48:00]: Template.render exit [09:48:00]: Template.__init__ enter, name = footer [09:48:00]: sourcefile =/usr/lib/lua/luci/view/footer.htm [09:48:00]: Template.__init__ exit [09:48:00]: Template.render enter, scope = { } [09:48:00]: Template.__init__ enter, name = themes/bootstrap/footer [09:48:00]: sourcefile =/usr/lib/lua/luci/view/themes/bootstrap/footer.htm [09:48:00]: Template.__init__ exit [09:48:00]: Template.render enter, scope = { ","date":"2022-08-04","objectID":"/openwrt-luci/:2:1","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"页面设置 显示的部分清楚了，那么设置呢？如果我们在页面上修改了一些参数，点击 Save 或者 Save \u0026 Apply 按钮，又发生了些什么？ 一句话概括就是：luci 通过 ubus 调用 rpcd 的 uci commit，然后 rpcd 发出 ubus 的 config.change event。 页面在修改配置后，会把修改的内容(uci change)存放在 /var/run/rpcd/uci-\u003csession\rid\u003e 目录下。这个其实是通过配置 uci 的 savedir 来实现的。 当点击按钮 Apply unchecked 或者 Save \u0026 Apply 的时候，浏览器会发 uri admin/uci/apply_rollback 或 admin/uci/apply_unchecked 的 request 给服务器 这里需要说明一下 apply_rollback 和 apply_unchecked 的区别。前者在应用新的配置的时候，如果出错，则会回滚（也就是退回到旧的配置）；而后者则不会。 根据 /usr/share/luci/menu.d/luci-base.json 的配置，会调用 /usr/lib/lua/luci/controller/admin/uci.lua 中的函数 action_apply_unchecked 或者函数 action_apply_rollback ，之后会调用 /usr/lib/lua/luci/model/uci.lua 中的 apply 函数。该函数会调用 ‘ubus call uci apply’，从而转到 rpcd。 接下来就会调用到 rpcd/uci.c 中的函数 rpc_uci_apply 。该函数会根据前面 /var/run/rpcd/uci-\u003csession id\u003e 中暂存的 uci 修改文件调用 rpc_uci_apply_config，来对每一个 config 进行处理。最终执行了函数 rpc_uci_trigger_event ，为每个提交的配置发出对应的 ubus 的 config.change 事件。 为帮助理解，我们打印出了修改 system 页面的 timezone 后，调用 apply 函数时当 rollback 为 false 的时候 - 和 -.changes 的内容 [10:46:13]: _= { changes = { system = { 1 = { 1 = 'set' 2 = 'cfg01e48a' 3 = 'timezone' 4 = 'CAT-2' } 2 = { 1 = 'set' 2 = 'cfg01e48a' 3 = 'zonename' 4 = 'Africa/Blantyre' } } } } { system = { 1 = { 1 = 'set' 2 = 'cfg01e48a' 3 = 'timezone' 4 = 'CAT-2' } 2 = { 1 = 'set' 2 = 'cfg01e48a' 3 = 'zonename' 4 = 'Africa/Blantyre' } } } 以 firewall 为例。在 /etc/init.d/firewall 脚本中，在系统启动时，通过 procd_add_reload_trigger firewall 由 procd 向 ubus 注册 config.change event。一旦 ubus 收到 config.change 事件，将触发 /etc/init.d/firewall reload _procd_add_reload_trigger() { local script=$(readlink \"$initscript\") local name=$(basename ${script:-$initscript}) local file _procd_open_trigger for file in \"$@\"; do _procd_add_config_trigger \"config.change\" \"$file\" /etc/init.d/$name reload done _procd_close_trigger } ","date":"2022-08-04","objectID":"/openwrt-luci/:2:2","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"LUCI 页面编写 ","date":"2022-08-04","objectID":"/openwrt-luci/:3:0","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"E() 是什么？ 我们经常看到 js 文件里有用 E() 函数包起来的内容。那么这个 E 到底是什么呢？查看代码可以发现 E 的定义在 cbi.js 中 function E(){return L.dom.create.apply(L.dom,arguments)} 所以这个 E() 其实只是 LuCI.dom.create() 的一个别名。 ","date":"2022-08-04","objectID":"/openwrt-luci/:3:1","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"Templates \u003c% code %\u003e 包含 lua 代码 \u003c% write(value) %\u003e 调用 lua 函数 \u003c%=value%\u003e 输出 lua 变量 \u003c% include(templateName) %\u003e 加载模板 \u003c%+templateName%\u003e 加载模板 \u003c%= translate(“Text to translate”) %\u003e 转换文本语言 \u003c%:Text to translate%\u003e 同上 \u003c%# comment %\u003e 注释 ","date":"2022-08-04","objectID":"/openwrt-luci/:3:2","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"menu.d ","date":"2022-08-04","objectID":"/openwrt-luci/:4:0","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"depends depends 用来配置这个节点对应的依赖条件，如果条件不满足，则节点不显示。（注意如果 uci 值改变并不会马上刷新 menu，必须要重新 login） 下面是一个例子，upnp 页面只有在 uci 的 option wireless.mesh.role 的值为 agent 的时候才显示。 \"admin/internet/upnp\": { \"title\": \"UPnP\", \"order\": 70, \"action\": { \"type\": \"view\", \"path\": \"sercomm-admin/upnp\" }, \"depends\": { \"acl\": [ \"luci-app-upnp\" ], \"uci\": { \"wireless\": {\"mesh\": {\"role\": \"agent\"} } } } } 对应的代码可以参考 check_uci_depends@dispatcher.lua 注意到 depends 后面的描述可以是一个 object (用 { } 表示），也可以是一个 array （用 [ ] 表示）。当为 object 的时候，里面的每一个选项之间是 and 的关系；当为 array 的时候，则为 or 的关系。 ","date":"2022-08-04","objectID":"/openwrt-luci/:4:1","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"FAQ ","date":"2022-08-04","objectID":"/openwrt-luci/:5:0","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"什么是 CBI ? CBI 是 Configuration Bind Interface 的缩写。在 老的源码 中有以下说明 Description: Offers an interface for binding configuration values to certain data types. Supports value and range validation and basic dependencies. 简单的理解，CBI 就是一个库，提供了一系列的接口用来在 UCI 的配置文件和相关的语言（lua 或者 js）的对象之间进行转换。 ","date":"2022-08-04","objectID":"/openwrt-luci/:5:1","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"为什么 LUCI 提供了 2 套 API? 翻看 luci 的官方说明文档，会发现提供了 2 套 api。一套是 lua 的，一套是 js 的。 根据资料，最初 luci 的设计是通过 lua 脚本来生成界面元素（后端），后来考虑到效率问题，把页面的生成转移到到了客户端浏览器（前端），所以改成了 js 的方式。 ","date":"2022-08-04","objectID":"/openwrt-luci/:5:2","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"有哪些相关的目录？ 从 openwrt 开发板的角度来看，有以下的相关目录或文件 /usr/share/luci/menu.d 存放菜单配置 /usr/share/luci/menu.d/luci-base.json [admin/status, type: firstchild] /usr/share/luci/menu.d/luci-mod-status.json [admin/status/overview, type: template, path: admin_status/index] /usr/lib/lua/luci/view/admin_status/index.htm [admin/status/iptables, type: view, path: status/iptables] luci-static/resources/view/status/iptables.js /www luci-static/resources/view 存放页面对应的 js 文件 /usr/lib/lua/luci /usr/lib/lua/luci/model 动态获取数据的 lua 脚本 /usr/lib/lua/luci/view htm 格式的静态网页文件 ","date":"2022-08-04","objectID":"/openwrt-luci/:5:3","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"LUCI 的 theme 是怎么应用的？ 相关的目录有 /usr/lib/lua/luci/view/themes/\u003cthemes-name\u003e 存放 header.htm 和 footer.htm /www/luci-static/\u003cthemes-name\u003e 存放相关的 css, js, image 等 /etc/uci-defaults /etc/config/luci 举例，你新创建了一个主题，名字叫 vodacom，那么通过以下指令可以切过去 uci set luci.main.mediaurlbase=/luci-static/vodacom uci commit luci 要恢复成老的界面，只需要 uci set luci.main.mediaurlbase=/luci-static/bootstrap uci commit luci ","date":"2022-08-04","objectID":"/openwrt-luci/:5:4","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"修改后如何更新？ 删除 cache rm -rf /tmp/luci-* 然后通过以下命令禁止 cache，这样以后就不用删除 cache 了 uci set luci.ccache.enable=0; uci commit luci ","date":"2022-08-04","objectID":"/openwrt-luci/:5:5","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"如何实时的显示或隐藏菜单项？ 这个问题稍微有点复杂，需要先分析一下菜单是如何显示的 首先，在客户端，会通过 menu.js 去获取菜单，大致的调用流程如下 - www/luci-static/resources/menu.js - ui.menu - UIMenu.load@ui.js - get url admin/menu 可以看到，最终是发送对 uri admin/menu 的请求，向服务器获取 menu 的内容 当服务器接收到请求后，就会根据 /usr/share/luci/menu.d/luci-base.json 的内容，找到 admin/menu 对应的 action，这里为调用 action_menu - action_menu - action_menu@usr/lib/lua/luci/controller/admin/index.lua - menu_json@/usr/lib/lua/dispatcher.lua 最终执行 dispatcher.lua 中的函数 menu_json 获得相应的内容，返回给客户端。 这里需要注意，luci 会把 menu 的内容存放在 cache （ /tmp/luci-* ）中。所以为了获取新的 menu，要将 cache 清空才行。 知道了原理，这个问题就有了思路。下面举例说明 假设 package mesh 包含了以下文件 /etc/config/mesh /www/luci-static/resources/view/system/mesh.js /usr/share/rpcd/acl.d/luci-base.json （添加部分 acl 控制） 配置文件 /etc/config/mesh 内容如下： config mesh 'mesh' option enabled '1' 其中 option enabled 控制了菜单 System-\u003eStartup 的显示与否。所以文件 /usr/share/luci/menu.d/luci-mod-system.json 中关于 Startup 页面的配置如下： \"admin/system/startup\": { \"title\": \"Startup\", \"order\": 45, \"action\": { \"type\": \"view\", \"path\": \"system/startup\" }, \"depends\": { \"uci\": { \"mesh\": {\"mesh\": {\"enabled\": \"1\"} } } } }, depends 就说明了页面的显示依赖于 mesh.mesh.enabled 的取值，当其为 1 的时候才显示。 为了达到目的， mesh.js 应该按照如下方式编写： 'use strict'; 'require view'; 'require ui'; 'require fs'; 'require uci'; 'require rpc'; 'require form'; return view.extend({ render: function() { var m, s, o; m = new form.Map('mesh',('Easy Mesh')); s = m.section(form.NamedSection, 'mesh', 'mesh'); o = s.option(form.Flag, 'enabled', _('Enable')); return m.render(); }, handleSaveApply: function(ev, mode) { return this.super('handleSaveApply', [ev, mode]).then(function() { console.log(\"handleSaveApply is called\"); fs.exec('/usr/bin/cl_luci_cache.sh').then(function() { if (L.ui.menu \u0026\u0026 L.ui.menu.flushCache) L.ui.menu.flushCache(); console.log(\"ui.flushCache is called\"); }) }); } }); 其中 /usr/bin/cl_luci_cache.sh 内容如下： #!/bin/sh /bin/rm -f /tmp/luci-indexcache* \u003e /dev/null 2\u003e\u00261 可以看到，在 apply 的时候，先调用脚本 /usr/bin/cl_luci_cache.sh 清除服务器端的 cache，然后再调用 L.ui.menu.flushCache 清楚客户端的 cache，重新跟服务器端索取 menu 的内容。 当然为了能执行脚本 /usr/bin/cl_luci_cache.sh ，还需要在 luci-base.json 中添加 acl 规则，内容如下： \"luci-app-mesh\": { \"description\": \"Grant access to mesh procedures\", \"read\": { \"uci\": [ \"mesh\" ] }, \"write\": { \"file\": { \"/usr/bin/cl_luci_cache.sh\": [ \"exec\" ] }, \"uci\": [ \"mesh\" ] } } 这样，就可以通过 enable/disable 页面上的 mesh enable 来显示或隐藏 Startup 页面了。 ","date":"2022-08-04","objectID":"/openwrt-luci/:5:6","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"调试 luci 的关键功能很多都是在 lua 脚本中实现的。因此我们常常需要添加一些调试信息来帮助理解。 一般的 debug 信息输出可以使用 luci.util.perror(\"blah blah\") 然后用 logread 就能看到输出。 为了打印更多的信息，我们可以在目录 /usr/lib/lua/luci 中添加文件 log.lua ，内容如下 local M = {} local tconcat = table.concat local tinsert = table.insert local srep = string.rep local function local_print(str) local dbg = io.open(\"/tmp/luci.output\", \"a+\") local str = str or \"\" if dbg then dbg:write(str..'\\n') dbg:close() end end function M.print(...) local dbg = io.open(\"/tmp/luci.output\", \"a+\") if dbg then dbg:write(os.date(\"[%H:%M:%S]: \")) for _, o in ipairs({...}) do dbg:write(tostring(o)..' ') end dbg:write(\"\\n\") dbg:close() end end function M.print_r(data, depth) local depth = depth or 3 local cstring = \"\"; local top_flag = true local function table_len(t) local i = 0 for k, v in pairs(t) do i = i + 1 end return i end local function tableprint(data,cstring, local_depth) if data == nil then local_print(\"core.print data is nil\"); end local cs = cstring .. \" \"; if top_flag then local_print(cstring ..\"{\"); top_flag = false end if(type(data)==\"table\") then for k, v in pairs(data) do if type(v) ~= \"table\" then if type(v) == \"string\" then local_print(cs..tostring(k)..\" = \"..\"'\"..tostring(v)..\"'\"); else local_print(cs..tostring(k)..\" = \"..tostring(v)); end elseif table_len(v) == 0 then local_print(cs..tostring(k)..\" = \"..\"{}\") elseif local_depth \u003c depth then local_print(cs..tostring(k)..\" = {\"); tableprint(v,cs,local_depth+1); else local_print(cs..tostring(k)..\" = \"..\"{*}\") end end else local_print(cs..tostring(data)); end local_print(cstring ..\"}\"); end tableprint(data,cstring,0); end return M 然后用类似以下的方式使用。比如在 dispatcher.lua 的开头添加 local log = require \"log.lua\" 在函数 dispatch 中打印 log.print(\"action.type =\"..action.type) log.print_r(action) 这样在刷新页面时，用以下命令就可以看到调试输出了 tail -f /tmp/luci.output 注意如果看不到输出，那可能是你的 cache 没有禁用或清除。 如果调试的时候要获取当前文件名，可以用以下函数 function __FILE__() return debug.getinfo(2, 'S').source:match(\"^.+/(.+)$\") end ","date":"2022-08-04","objectID":"/openwrt-luci/:6:0","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"参考 luci_tutorials Description of the JSON in menu.d and acl.d https://github.com/openwrt/luci/tree/master/docs https://openwrt.org/docs/guide-developer/luci http://openwrt.github.io/luci/jsapi/index.html Howto write new LuCI apps Example to convert lua to js HowTo: Setting up a Development Environment LuCI入门 LuCI之CBI LuCI之UCI OpenWrt达人教程之开发人员入门指南 luci example ","date":"2022-08-04","objectID":"/openwrt-luci/:7:0","tags":null,"title":"openwrt LUCI工作原理浅析","uri":"/openwrt-luci/"},{"categories":null,"content":"概述 使用 proc 虚拟文件系统来在内核空间和用户空间交换数据应该是最常用的一种方式了。我们可以在 /proc 目录下创建一个虚拟的文件，通过读写这个文件实现用户空间和内核空间的数据交互。 需要说明的是，虽然这里我们只讨论 procfs，但是在在新一些的 linux kernel 中我们应该使用 sysfs 来替代 procfs 作为 driver 和 user space 的接口。 ","date":"2022-08-01","objectID":"/linux_proc/:1:0","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"代码示例 废话不多说，先上例子。（例子是基于 linux 3.9.9 测试的，但是理论上适用于到目前为止的所有 kernel 版本） /* * procfs1.c */ #include \u003clinux/kernel.h\u003e /* We're doing kernel work */#include \u003clinux/module.h\u003e /* Specifically, a module */#include \u003clinux/proc_fs.h\u003e /* Necessary because we use the proc fs */#include \u003clinux/uaccess.h\u003e /* for copy_from_user */#include \u003clinux/version.h\u003e #if LINUX_VERSION_CODE \u003e= KERNEL_VERSION(5, 6, 0) #define HAVE_PROC_OPS #endif #if LINUX_VERSION_CODE \u003c KERNEL_VERSION(3, 10, 0) #define HAVE_PROC_READ_SUITE #endif #define PROCFS_MAX_SIZE 1024 #define PROCFS_NAME \"pbuf\" /* This structure hold information about the /proc file */ static struct proc_dir_entry *our_proc_file; /* The buffer used to store character for this module */ static char procfs_buffer[PROCFS_MAX_SIZE]; /* The size of the buffer */ static unsigned long procfs_buffer_size = 0; static ssize_t procfile_read(struct file *file, const char __user *buff, size_t len, loff_t *off) { int plen = procfs_buffer_size; ssize_t ret = plen; if (*off \u003e= plen || copy_to_user(buff, procfs_buffer, plen)) { pr_info(\"copy_to_user failed\\n\"); ret = 0; } else { pr_info(\"procfile read %s\\n\", file-\u003ef_path.dentry-\u003ed_name.name); *off += plen; } return ret; } /* cat /dev/zero | tr \"\\0\" \"a\" | dd of=/tmp/1.txt bs=1023 count=1 cat /tmp/1.txt \u003e /proc/pbuf */ static ssize_t procfile_write(struct file *file, const char __user *buff, size_t len, loff_t *off) { procfs_buffer_size = len; if (procfs_buffer_size \u003e PROCFS_MAX_SIZE) procfs_buffer_size = PROCFS_MAX_SIZE; if (copy_from_user(procfs_buffer, buff, procfs_buffer_size)) { pr_info(\"copy_from_user failed\\n\"); return -EFAULT; } /* supports only max to 1023 bytes string */ procfs_buffer[procfs_buffer_size \u0026 (PROCFS_MAX_SIZE - 1)] = '\\0'; pr_info(\"procfile write %s\\n\", procfs_buffer); return procfs_buffer_size; } #ifdef HAVE_PROC_OPS static const struct proc_ops proc_file_fops = { .proc_read = procfile_read, .proc_write = procfile_write, }; #else static const struct file_operations proc_file_fops = { .read = procfile_read, .write = procfile_write, }; #endif static int __init procfs1_init(void) { our_proc_file = proc_create(PROCFS_NAME, 0644, NULL, \u0026proc_file_fops); if (NULL == our_proc_file) { #ifdef HAVE_PROC_READ_SUITE remove_proc_entry(PROCFS_NAME, NULL); #else proc_remove(our_proc_file); #endif pr_alert(\"Error:Could not initialize /proc/%s\\n\", PROCFS_NAME); return -ENOMEM; } pr_info(\"/proc/%s created\\n\", PROCFS_NAME); return 0; } static void __exit procfs1_exit(void) { #ifdef HAVE_PROC_READ_SUITE remove_proc_entry(PROCFS_NAME, NULL); #else proc_remove(our_proc_file); #endif pr_info(\"/proc/%s removed\\n\", PROCFS_NAME); } module_init(procfs1_init); module_exit(procfs1_exit); MODULE_LICENSE(\"GPL\"); 为了测试方便 Makefile 也随手贴一下，注意路径自己定义 KERNEL_DIR= ARCH= CROSS_COMPILE= obj-m += procfs1.o ccflags-y := -g -DDEBUG .PHONY: all clean PWD := $(CURDIR) all: $(MAKE) -C '$(KERNEL_DIR)' M='$(PWD)' ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) V=1 modules clean: $(MAKE) -C '$(KERNEL_DIR)' M='$(PWD)' clean 编译后会生成模块文件 procfs1.ko 。在对应的 linux guest 机器上测试 $ insmod procfs1.ko $ echo 'HelloWorld!' \u003e /proc/pbuf procfile write HelloWorld! $ cat /proc/pbuf procfile read pbuf HelloWorld! copy_to_user failed copy_to_user failed ","date":"2022-08-01","objectID":"/linux_proc/:2:0","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"使用说明 ","date":"2022-08-01","objectID":"/linux_proc/:3:0","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"关键接口函数和结构 从上例可以看出，创建一个 proc 虚拟文件包含了以下的几个步骤 定义一个 struct proc_ops 或者 struct file_operations 的实例，read 和 write 的函数指向自定义的 procfile_read 和 procfile_write 回调函数 调用函数 proc_create 创建一个虚拟文件，并将参数 proc_fops 对应的 struct\rfile_operations 实例与之关联 实现读写的回调函数 procfile_read 和 procfile_write 在模块退出时，调用函数 remove_proc_entry 或者 proc_remove 将 proc 虚拟文件删除 对应的几个函数都可以在头文件 include/linux/proc_fs.h 中找到声明 struct proc_dir_entry *proc_create_data(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct file_operations *proc_fops, void *data); static inline struct proc_dir_entry *proc_create(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct file_operations *proc_fops) { return proc_create_data(name, mode, parent, proc_fops, NULL); } extern void remove_proc_entry(const char *name, struct proc_dir_entry *parent); 主要的数据结构则是 struct proc_dir_entry struct proc_dir_entry { // ... const struct inode_operations *proc_iops; const struct file_operations *proc_dir_ops; // ... }; struct file_operations { // ... ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); // ... }; 从上面的分析可以知道，最重要的就是 procfile_read 和 procfile_write 两个回调函数了。write 函数的参数说明如下： /* procfile_write函数将数据从用户空间的buff 中拷贝到文件的 (*off) 位置处。 file: [IN] 文件指针 buff: [IN] 需要写入文件的数据起始指针。注意这个buff是在user space的，所以需要使 用copy_from_user 拷贝到内核空间。同时需要注意 copy_from_user 函数返回的是 还没有被拷贝到用户空间去的数据长度，而不是像一般的返回拷贝成功的长度。 len: [IN] 需要写入的数据长度 off: [IN/OUT] 表示文件的偏移地址offset。数据应该从 buff 的位置开始写入到文件的 (*off) 偏移出。每一次被调用后，函数需要根据写入的数据长度调整 (*off) 的值。 return: 成功写入的数据长度 */ static ssize_t procfile_write(struct file *file, const char __user *buff, size_t len, loff_t *off) /* procfile_read 函数负责从文件的（*off）位置拷贝数据到用户空间的 buff 中去。 file: [IN] 文件指针 buff: [OUT] 需要读出的数据的存放位置。注意这个buff是在user space的，所以需要使用 copy_to_user 拷贝到用户空间。同时需要注意 copy_to_user 函数返回的是还没有 被拷贝到用户空间去的数据长度，而不是像一般的返回拷贝成功的长度。 len: [IN] 需要读取的数据长度 off: [IN/OUT] 表示文件的偏移地址offset。数据应该从文件的(*off) 偏移处读取到 buff 中。每一次被调用后，函数需要根据已经读取的数据长度调整 (*off) 的值。 return: 成功读取的数据长度 */ static ssize_t procfile_read(struct file *file, const char __user *buff, size_t len, loff_t *off) 这两个函数的具体说明可以参考 Linux Device Drivers, Third Edition 的第三章讲解的 read 和 write 函数部分，大同小异。 ","date":"2022-08-01","objectID":"/linux_proc/:3:1","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"深入 procfile_read 了解了接口函数的使用，我们可以回到先前的例子再仔细分析一下输出。可以看到在 cat\r/proc/pbuf 的时候打印了两次的 “copy_to_user failed”。为什么会打印两次呢？ 因为 cat 默认是使用 sendfile 函数来直接在 kernel space 中从 /proc/pbuf 文件传递数据到 stdout 的。只有当 sendfile 返回值为 0（eof）的时候 cat 才会退出。 对于 /proc/pbuf 文件的读回调函数来说，其调用栈如下 1 procfile_read procfs1.c 30 0xc87e602a 2 proc_reg_read inode.c 197 0xc10c82d8 3 do_loop_readv_writev read_write.c 636 0xc108d7a9 4 do_readv_writev read_write.c 768 0xc108d9ac 5 vfs_readv read_write.c 790 0xc108d9eb 6 kernel_readv splice.c 567 0xc10ab12d 7 default_file_splice_read splice.c 643 0xc10ac9e6 8 do_splice_to splice.c 1146 0xc10ab496 9 splice_direct_to_actor splice.c 1217 0xc10ab561 10 do_splice_direct splice.c 1307 0xc10acce2 11 do_sendfile read_write.c 968 0xc108ddff 12 sys_sendfile64 read_write.c 1023 0xc108dfde 13 ia32_sysenter_target entry_32.S 439 0xc12733be 14 ?? 0xffffe424 15 ?? 0x804fd47 16 ?? 0x80e9616 由于函数 splice_direct_to_actor 中会循环调用 do_splice_to 函数来传递数据，直到返回值为 0 （也就是 /proc/pbuf 的读回调函数返回 0）。所以其实 do_sendfile 被调用了 2 次，而 procfile_read 则被调用了 3 次。过程如下所示： - do_sendfile (return 13) - procfile_read (return 13) - procfile_read (return 0) - do_sendfile (return 0) - procfile_read (return 0) ","date":"2022-08-01","objectID":"/linux_proc/:3:2","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"接口函数的演变 为什么在上面的示例代码里那么多的宏？这是因为随着 linux kernel 的不断更新，proc 虚拟文件的使用方式也发生了多次变化。最重要的变化如下表所示（参见头文件 include/linux/proc_fs.h ） VERSION CHANGE v3.10 remove read_proc and write_proc from struct proc_dir_entry v5.6 use ‘struct proc_ops’ to instead of ‘struct file_operation’ 翻看 3.10 以前的 linux kernel，可以看到 proc 文件系统的核心数据结构 proc_dir_entry 如下所示： struct proc_dir_entry { // ... const struct inode_operations *proc_iops; // Inode operations functions const struct file_operations *proc_fops; // File operations functions // ... read_proc_t *read_proc; // proc read function write_proc_t *write_proc; // proc write function // ... }; struct file_operations { // ... ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); // ... }; 也就是说读写文件可以通过两种方式进行 A. 通过调用 proc 提供的函数指针接口 read_proc 和 write_proc B. 通过标准的文件系统接口 proc_fops-\u003eread 和 proc_fops-\u003ewrite 再看下 5.6 的数据结构（ fs/proc/internal.h ） struct proc_dir_entry { // ... const struct inode_operations *proc_iops; union { const struct proc_ops *proc_ops; const struct file_operations *proc_dir_ops; }; // ... }; struct proc_ops { // ... ssize_t (*proc_read)(struct file *, char __user *, size_t, loff_t *); ssize_t (*proc_write)(struct file *, const char __user *, size_t, loff_t *); // ... } __randomize_layout; 可以发现， read_proc 和 write_proc 接口被移除了；同时多了一个 struct proc_ops 结构指针。之所以把原来的 struct file_operations 替换为 struct\rproc_ops ，原因是 struct file_operations 包含了很多 VFS 不需要的成员；替换成 struct proc_ops 作为 proc VFS 专用的结构体，可以避免在 struct\rfile_operations 增加新功能的时候影响 proc VFS，也可以通过在 struct proc_ops 中添加特定的一些成员来扩展 proc VFS 的功能。 由于 proc_ops-\u003eproc_read 和 proc_ops-\u003eproc_write 函数原型和 file_operations-\u003eread ， file_operations-\u003ewrite 完全一样。所以最佳使用方式应该是通过文件系统来读取 proc 的虚拟文件。这样不管是 5.6 之前的 file_operations 或者之后的 proc_ops 都可以使用一样的 read write 函数了。 ","date":"2022-08-01","objectID":"/linux_proc/:3:3","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"高级应用 ","date":"2022-08-01","objectID":"/linux_proc/:4:0","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"数据量大于 PAGE_SIZE 如果仔细阅读上面的代码就会注意到，这个例子中的 readfile_proc 只能支持数据量小于等于一个 PAGE_SIZE 的情形。如果需要读取大于一个 PAGE_SIZE 的数据，那么函数应该怎么写呢？示例如下： #define PROCFS_MAX_SIZE (1024*8) /* The buffer used to store character for this module */ static char procfs_buffer[PROCFS_MAX_SIZE]; /* The size of the buffer */ static unsigned long procfs_buffer_size = 0; static ssize_t procfile_read(struct file *file, const char __user *buff, size_t len, loff_t *off) { size_t count = len, data_length = sizeof(procfs_buffer); ssize_t retval = 0; unsigned long ret = 0; if (*off \u003e= data_length) goto out; if (*off + len \u003e data_length) count = data_length - *off; /* ret contains the amount of chars wasn't successfully written to `buf` */ ret = copy_to_user(buff, procfs_buffer + *off, count); *off += count - ret; retval = count - ret; out: return retval; } /* cat /dev/zero | tr \"\\0\" \"a\" | dd of=/tmp/1.txt bs=1023 count=1 cat /tmp/1.txt \u003e /proc/pbuf */ static ssize_t procfile_write(struct file *file, const char __user *buff, size_t len, loff_t *off) { unsigned long write_size = len; unsigned long left_size = PROCFS_MAX_SIZE - procfs_buffer_size; if (write_size \u003e left_size) write_size = left_size; if (copy_from_user(procfs_buffer + procfs_buffer_size, buff, write_size)) { pr_info(\"copy_from_user failed\\n\"); return -EFAULT; } pr_info(\"procfile write offset %lu with length %lu\\n\", procfs_buffer_size, write_size); procfs_buffer_size += write_size; *off += write_size; return write_size; } ","date":"2022-08-01","objectID":"/linux_proc/:4:1","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"proc 专用接口 如果是使用的是 3.10 以后的内核版本，那么请出门右转，因为下面的内容对你帮助不大。新的内核已经不支持这种使用方式。但是如果你使用的还是旧版的 kernel，那么请仔细的往下看。因为在网络上搜一下就会发现，很少有文档会去详细解释这个接口怎么使用。或者解释了也是云里雾里，很难看懂。 在看我写的文字之前，建议先学习一下 kernel 自带的文档和例程，毕竟这才是最权威的 Linux Kernel Procfs Guide procfs_example.c 然后如果还不明白，可以参考我下面的补充说明。 ","date":"2022-08-01","objectID":"/linux_proc/:5:0","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"实例说明 还是老规矩，先举例子，如果你只是想用一下，不想知道太多（很忙），那么照例子写就完了。由于 proc 的专用接口提供了几种写法，所以需要分情况来举例。（就很烦） 由于 write 回调函数相对比较清楚，我只对 read 函数进行分析。 传输数据量小于等于一个 PAGE_SIZE 在早期的 linux kernel 中，有大量的使用 proc 专用接口来读写 proc 虚拟文件的例子。主要有以下的两种 写法 A \r static int ap_debug_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data) { char *p = page; struct ap_data *ap = (struct ap_data *) data; if (off != 0) { *eof = 1; return 0; } p += sprintf(p, \"BridgedUnicastFrames=%u\\n\", ap-\u003ebridged_unicast); p += sprintf(p, \"BridgedMulticastFrames=%u\\n\", ap-\u003ebridged_multicast); return (p - page); } 写法 B \r static int ap_debug_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data) { char *p = page; struct ap_data *ap = (struct ap_data *) data; p += sprintf(p, \"BridgedUnicastFrames=%u\\n\", ap-\u003ebridged_unicast); p += sprintf(p, \"BridgedMulticastFrames=%u\\n\", ap-\u003ebridged_multicast); *eof = 1; return (p - page); } 如果查看调用这个回调函数的函数 __proc_file_read （实现在文件 fs/proc/generic.c 中）就可以发现，B 的写法要更好一些，A 则会多循环一次。 这种写法其实也就是在函数 __proc_file_read 注释中提到的 3 种做法中的第一种。原文摘录如下: Leave *start = NULL. (This is the default.) Put the data of the requested offset at that offset within the buffer. Return the number (n) of bytes there are from the beginning of the buffer up to the last byte of data. If the number of supplied bytes (= n - offset) is greater than zero and you didn't signal eof and the reader is prepared to take more data you will be called again with the requested offset advanced by the number of bytes absorbed. This interface is useful for files no larger than the buffer. 还不理解是不是？换种说法 1st call: - *start = NULL # enter proc_read - memcpy(page + offset, internal_data + offset, data_copied_to_page_len) - data_copied_to_user_len = data_copied_to_page_len - return (offset + data_copied_to_user_len) # exit proc_read - copy data of data_copied_to_user_len from kernel space (page + offset) to user space (buf + offset) - offset += data_copied_to_user_len 2nd call: - *start = NULL # enter proc_read - memcpy(page + offset, internal_data + offset, data_copied_to_page_len) - data_copied_to_user_len = data_copied_to_page_len - return (offset + data_copied_to_user_len) # exit proc_read - copy data of data_copied_to_user_len from kernel space (page + offset) to user space (buf + offset) - offset += data_copied_to_user_len 在这种情况下，start 不被使用。需要关注的只有 offset 和 eof 。 从前面的函数调用可以看出，虽然一般用 eof 来判断是否读取结束，但是即使没有设置 eof 也能结束读取循环。只要把数据读取结束即可。只是这样容易出错且效率低，所以显式的指定 eof 是个更好的编程习惯。 如果对于 offset 和 eof 的理解还是不够清楚，可以参考 stackoverflow 上的一段举例，我觉得还是挺清楚的。 off is the position in the file from where data has to be read from. This is like off set of normal file. But, in the case of proc_read it is some what different. For example if you invoke a read call on the proc file to read 100 bytes of data, off and count in the proc_read will be like this: in the first time, off = 0, count 100. Say for example in your proc_read you have returned only 10 bytes. Then the control cannot come back to the user application, your proc_read will be called by the kernel once again with off as 10 and count as 90. Again if you return 20 in the proc_read, you will again called with off 30, count 70. Like this you will be called till count reaches 0. Then the data is written into the given user buffer and your application read() call returns. But if you don't have hundred bytes of data and want to return only a few bytes, you must set the eof to 1. Then the read() function returns immediately. 传输数据量大于一个 PAGE_SIZE 还是先看例子 #define BUFSIZ 8192 static char output_data[BUFSIZ] = {0}; static int read_method2(char *page, char **start, off_t offset, int count, int *eof, void *data) { int len = strlen(output_data); int read_size = PAGE_SIZE-1; // suppose PAGE_SIZE is 4K if (offset \u003e= len) { *eof = 1; return 0; } memcpy(page, output_data+offset, read_size); *start = read_size; return (read_size); } 所以如果 caller 请求读取的是 8K 字节，那么第一次调用 read_proc 的时候 offset 0， count 8192；第二次 offset = offset + (*start) ，即 4095 (4K-1)，count 4097；第三次 offset 81","date":"2022-08-01","objectID":"/linux_proc/:5:1","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"参考 The Linux Kernel Module Programming Guide Access the Linux kernel using the /proc filesystem Linux Kernel Procfs Guide What is the difference between procfs and sysfs? ","date":"2022-08-01","objectID":"/linux_proc/:6:0","tags":["kernel"],"title":"内核空间和用户空间通信 - proc 虚拟文件系统","uri":"/linux_proc/"},{"categories":null,"content":"谈到信息安全，我只能算是个门外汉。但是由于工作需求，经常也会接触一些，所以整理一下备查。顺便也把自己的一些心得分享出来。 ","date":"2022-07-01","objectID":"/security/:0:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"关键字 我们在看跟安全相关的文献的时候，最常看到的就是以下的一些词汇。理解它们对于理解相关技术是很重要的。 Confidentiality 保密性 Encrypt 加密 Integrity 完整性（你有没有被篡改过？） Authentication 认证（你是谁？） ","date":"2022-07-01","objectID":"/security/:1:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"相关技术 所有的技术都是为了满足应用的需求而产生。安全技术也不例外。 ","date":"2022-07-01","objectID":"/security/:2:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"对称加密算法 考虑一个场景。A 是一个地下工作者，每隔一段时间，他都要和自己的上线 B 联系传递信息。为了保证信息不被窃听，A 需要把自己的信息加密之后再发送给 B，而 B 要做的就是解密并查看 A 给他的信息。之后 B 同样的也可以加密自己的信息再传递给 A。 这里用到的加解密，最常用的方式就是对称式的加密算法了。也就是双方都拥有一个相同的秘钥（key），然后使用相同的算法来加密或者解密，最终获得明文。 这样的加密算法有很多，通过 man openssl -\u003e Encoding and Cipher Commands 可以看到一些常用的算法列表。 ","date":"2022-07-01","objectID":"/security/:2:1","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"非对称加密算法（公钥加密） 这样的方式很简便快捷，但是存在一个问题。那就是 A 的秘钥每次更新的时候都必须通知 B 以进行同步。这个通知的过程就存在着的泄漏的风险。 于是 A B 在商量之后更新了他们的加密策略，采用了公钥加密算法。 公钥加密算法和对称加密算法不同，包含了 2 个 key。一个私钥（private key）和一个公钥（public key）。公钥可以公开发布，用来加密信息；而私钥只会妥善保存好，用来解密公钥加密的信息。因为私钥不会被传播，所以就解决了对称性加密带来的秘钥泄漏的风险。注意，虽然一般情况下我们都是用公钥加密私钥解密，但是逆过来也是可行的。私钥加密的信息，使用公钥同样可以解密。 比较典型的非对称加密算法就是 RSA 了。 ","date":"2022-07-01","objectID":"/security/:2:2","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"PKI 但是怎么确定 B 拿到的公钥是属于 A 的呢？如果中间有人偷偷把 A 发给 B 的公钥换掉了，那不就可以伪装成 A 了吗？ PKI 隆重登场。PKI 中文译为公钥基础设施，它是英文 Public Key Infrastructure 的缩写，基于公钥密码学，建立起一种普遍适用的基础设施，为各种网络应用提供全面的安全服务。 我们可以简单的认为 PKI 体系就是为了沟通的双方安全的拿到对方的秘钥（真实，完整）。 PKI 基本结构由证书认证机构（certificate authority, CA）、证书持有者（certificate holder）、依赖方（relying party）三方构成 CA 是一个独立的可信第三方，为证书持有者签发数字证书，数字证书中声明了证书持有者的身份和公钥。CA 在签发证书前应对证书持有者的身份信息进行核实验证，并根据其核验结果为其签发证书。 证书持有者向 CA 申请数字证书，并向 CA 提供必要的信息以证明其身份及能力，获得由 CA 签发的证书；证书持有者在与依赖方进行交互时，需向依赖方提供由 CA 签发的数字证书证明其有效身份。 依赖方是证书的验证方，依赖方与证书持有者进行交互（如建立通信连接）时，需获取证书持有者的数字证书，验证数字证书的真实性和有效性。依赖方可以指定其信任的 CA 列表，若证书持有者提供的数字证书不是受信 CA 签发的数字证书，依赖方将不认可该证书所声明的信息。 所以三者的关系，简单来说就如下图： +--------------+ +-----\u003e | CA | \u003c----+ | +----+ +--------------+ | request | | identify | certficiate | | issue certificate | trust | | | | v | | provide | +-------------+ certificate +-------------+ | certificate | +---------\u003e | relay party | | holder | \u003c---------+ | | +-------------+ verifiy +-------------+ certificate 证书存在的意义在于回答“公钥属于谁”的问题，以帮助用户安全地获得对方的公开密钥。 在理解了 PKI 之后，我们再来看 A B 可以如何交互 私钥(key - private key) 证书请求(csr - certificate signing request) 签名证书(crt - certificate signed request) \r A CA B + + + | | | generate a pair | | | of keys | | | | send csr | | | +-------------------\u003e | | | | | | 1. verify identity | | | 2. sign the csr | | | 3. send back the cer | | | \u003c-------------------+ | | | | | | | | | send A's crt to B | | | +----------------------------\u003e | 1. verify with CA's cert | | | 2. store A's public key | | | | | | | send data to A| | decrypt with A's | \u003c----------------------------+ | encrypt data with private key | | | A's public key | | | | | | | | | | | | + + + 图示只标注了 B 往 A 发送数据的过程，如果是 A 往 B 传递信息，那么同样的方法，只是换成使用 B 的 key 而已。 在这里面还有几点需要说明的 所谓的签名，其实可以简单的理解成把原始证书先做 hash，再使用 CA 的 private key 对这个 hash 值进行加密，最后添加到证书里面的一个过程 证书可以由 CA 签名，也可以自签名 证书一般使用 X509 的格式，其中中包含了持有者的公钥和发布者的签名，以及其他的一些表明证书身份相关的信息 CA CA 分为 Signed CA 和 Self Signed CA。两者的差别在于其证书（certificate）被认证的方式不同。 Self Signed CA 是指由自己给自己的 certificate 做签名认证的 CA ，由于一般来讲此类 CA 总是处于 CA 链的最顶端，所以又叫 Root CA。 Signed CA 是指 certificate 由其他 CA 进行签名认证的 CA。而认证它的 CA，我们称为 Signed CA 的上层 CA，也叫 Parent CA；而 Signed CA 则称为 Sub CA 或 Child CA。 ","date":"2022-07-01","objectID":"/security/:2:3","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"实例说明 ","date":"2022-07-01","objectID":"/security/:3:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"PKI 下面，就用 openssl 举例生成 RSA 的 CA 和用户证书。 生成 CA 的私钥 [fog@fog-ibm ca] openssl genrsa -des3 -out ca.key 1024 Generating RSA private key, 1024 bit long modulus ...........................+++++ ............................................+++++ e is 65537 (0x10001) Enter PEM pass phrase: Verifying password - Enter PEM pass phrase: Please backup this ca.key file and remember the pass-phrase you had to enter at a secure location. 生成 CA 的自我签名证书 fog@tmp$ openssl req -new -x509 -days 365 -key ca.key -out ca.crt Enter pass phrase for ca.key: You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [AU]: State or Province Name (full name) [Some-State]: Locality Name (eg, city) []: Organization Name (eg, company) [Internet Widgits Pty Ltd]: Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []:Fog Email Address []: 查看一下生成的证书 fog@tmp$ openssl x509 -noout -text -in ca.crt Certificate: Data: Version: 3 (0x2) Serial Number: 6c:5b:7a:5c:37:e3:1b:2d:99:2d:99:20:79:54:c4:d6:52:9e:20:17 Signature Algorithm: sha256WithRSAEncryption Issuer: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog Validity Not Before: Jul 5 08:43:44 2022 GMT Not After : Jul 5 08:43:44 2023 GMT Subject: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (1024 bit) Modulus: 00:c2:ad:39:a9:64:a5:85:5b:39:ab:eb:a8:da:82: 66:90:60:f9:35:d9:ea:67:4e:6f:d6:99:14:1c:32: 6a:23:e4:03:eb:11:44:1a:94:4d:42:a1:74:9e:26: 62:10:0b:4b:a8:3c:10:28:32:c9:d9:1b:34:aa:03: 5d:d6:63:70:32:68:c0:d2:9d:17:e7:b4:47:6e:6e: 86:66:a5:bc:f1:52:4e:2a:47:2a:0e:7b:00:d7:f9: d0:70:c2:12:58🆎df:b3:82:51:23:cf:a8:59:40: c6:a7:7e:f6:8c:91:1e:00:42:87:d1:42:1c:98:15: 4e:ff:1c:38:55:8a:d1:9d:fb Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 3F:46:C9:DA:5C:4E:60:65:CB:48:8E:DF:FE:92:67:2C:03:A4:B0:A1 X509v3 Authority Key Identifier: keyid:3F:46:C9:DA:5C:4E:60:65:CB:48:8E:DF:FE:92:67:2C:03:A4:B0:A1 X509v3 Basic Constraints: critical CA:TRUE Signature Algorithm: sha256WithRSAEncryption 72:98:2c:4b:ac:5d:3e:aa:21:ca:5f:46:1a:b9:14:2c:2f:b8: e9:3d:8a:bd:19:ea:da:32:13:fc:02:9c:f7:f2:2b:99:56:20: 11:86:5b:7c:1b:ea:5a:0e:f4:bd:da:e2:44:ec:b9:71:7b:3a: 01:a3:d1:dc:bc:fc:52:49:6a:c8:f4:2c:27:45:ab:e6:65:bf: 75:75:1e:66:56:cc:82:71:95:7f:0b:da:8a:bf:2d:b6:7b:fd: 72:a2:68:f5:13:59:6f:ac:72:20:bf:59:0c:20:60:3d:46:6e: d7:4c:83:90:42🆎04:b9:e1:e4:9f:1c:7e:1e:2f:96:32:b0: 89:6e 这里我们就可以看到一个 x509 格式的证书包含了哪些字段。这个对于理解证书很重要，所以详细分析一下 Issuer: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog Subject: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog 因为这是一个自签名的证书，所以 Issuer 和 Subject 的内容是一样（Issuer 表示是谁颁发的证书，而 Subject 表示这个证书属于谁）。 Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (1024 bit) Public Key Info 告诉我们这个 Public Key 对应的加密算法是 RSA，秘钥为 1024 bit，然后明文附上了对应的秘钥（注意这是秘钥对里面的 public key）。 X509v3 extensions: X509v3 Basic Constraints: critical CA:TRUE 这里可以看到 CA 的值是 TRUE，表示这个证书可以作为 CA 证书使用。 Signature Algorithm: sha256WithRSAEncryption 签名的算法为先用 sha256 做 hash 算法，然后再用 RSA 算法使用 Issuer 的 private key 进行加密。 生成用户的私有密钥 fog@tmp$ openssl genrsa -des3 -out my.key 1024 生成用户的签名请求证书 fog@tmp$ openssl req -new -key my.key -out my.csr 由 CA 为请求证书签名 fog@tmp$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in my.csr -out my.crt -days 365 现在再来看看这个生成的证书是什么样的 fog@tmp$ openssl x509 -noout -text -in my.crt Certificate: Data: Version: 1 (0x0) Serial Number: 14:a2:7c:94:fa:b8:0c:28:0d:9b:c3:86:44:3a:cf:40:0e:ea:71:c3 Signature Algorithm: sha256WithRSAEncryption Issuer: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = Fog Valid","date":"2022-07-01","objectID":"/security/:3:1","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":null,"content":"Reference Difference between self-signed CA and self-signed certificate TLS encryption and mutual authentication using syslog-ng Open Source Edition Making sense of SSL, RSA, X509 and CSR A journey into verifying signatures on x.509 certificates ","date":"2022-07-01","objectID":"/security/:4:0","tags":null,"title":"信息安全技术入门","uri":"/security/"},{"categories":["programming"],"content":"函数原型 #include \u003cstring.h\u003e char *strncpy(char *dest, const char *src, size_t n); ","date":"2022-06-30","objectID":"/strncpy/:1:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"用法分析 strncpy 由于添加了长度限制，避免了缓冲区溢出的问题。但在使用这个函数的时候必须要注意: strncpy 只有在源字符串的长度小于参数 n 时，它才会用 NUL(或者'\\0')来结束字符串。 因此正确的使用 strncpy 的方法是，当拷贝源字符串的一部分时，使用 strncpy 之后，自己手工添加 NUL 来结束字符串。 #define BUFSIZ 265 int main(int argc, char **argv) { char buf[BUFSIZ]; strncpy(buf, argv[1], sizeof(buf) - 1); buf[sizeof(buf) - 1] = '\\0'; /* 防止buf没有初始化为0，结束字符串 */ return 0; } 这里可以看到，要正确使用 strncpy 还是挺麻烦的一件事情。 ","date":"2022-06-30","objectID":"/strncpy/:2:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"注意事项 ","date":"2022-06-30","objectID":"/strncpy/:3:0","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"strlcpy 其实在 openbsd 里面提供了一个库函数 strlcpy 。它保证了目的字串总是以 NUL 结尾，并且返回值总是目的字串的全长(不包括 NUL)。其源码如下 /* $OpenBSD: strlcpy.c,v 1.11 2006/05/05 15:27:38 millert Exp $ */ /* * Copyright (c) 1998 Todd C. Miller \u003cTodd.Miller@courtesan.com\u003e * * Permission to use, copy, modify, and distribute this software for any * purpose with or without fee is hereby granted, provided that the above * copyright notice and this permission notice appear in all copies. * * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */ #include \u003csys/types.h\u003e#include \u003cstring.h\u003e /* * Copy src to string dst of size siz. At most siz-1 characters * will be copied. Always NUL terminates (unless siz == 0). * Returns strlen(src); if retval \u003e= siz, truncation occurred. */ size_t strlcpy(char *dst, const char *src, size_t siz) { char *d = dst; const char *s = src; size_t n = siz; /* Copy as many bytes as will fit */ if (n != 0) { while (--n != 0) { if ((*d++ = *s++) == '\\0') break; } } /* Not enough room in dst, add NUL and traverse rest of src */ if (n == 0) { if (siz != 0) *d = '\\0'; /* NUL-terminate dst */ while (*s++) ; } return(s - src - 1); /* count does not include NUL */ } ","date":"2022-06-30","objectID":"/strncpy/:3:1","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["programming"],"content":"strncpy vs snprintf 除了使用 strlcpy，还有个好的选择是使用 snprintf。 snprinf 可以完成 strncpy 的功能，而且比 strncpy 更有效率。看一下 glibc 中 strncpy 的代码 char * STRNCPY (char *s1, const char *s2, size_t n) { size_t size = __strnlen (s2, n); if (size != n) memset (s1 + size, '\\0', n - size); return memcpy (s1, s2, size); } 我们可以看到，当 s2 的长度小于 n 的时候，strncpy 会把 s1 中从 s2 的长度以后的所有字节都设置成 '\\0' ，显然，这个对于我们大部分情况下的需求来说是没有必要的，只要将字符串的最后一个字节置 NULL 即可。这也是 snprinf 的做法。 ","date":"2022-06-30","objectID":"/strncpy/:3:2","tags":["c"],"title":"C 语言常用库函数-strncpy","uri":"/strncpy/"},{"categories":["network"],"content":"概述 ","date":"2022-02-07","objectID":"/wireless/:1:0","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"从一次正常的连接说起 先从一次简单的连接看起。测试环境就是一台无线 STA 和一个 AP，以及一台用来抓包的 PC 。 +--------+ +-------+ | STA | | AP | +--------+ +-------+ +---------+ | capture | | PC | +---------+ 通过 PC 用 wireshark 来抓取 STA 和 AP 之间的无线数据报文。 ","date":"2022-02-07","objectID":"/wireless/:2:0","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"管理报文 先看看管理报文 Wireless Management PacketsWireless Management Packets \" Wireless Management Packets ","date":"2022-02-07","objectID":"/wireless/:2:1","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"数据报文 ","date":"2022-02-07","objectID":"/wireless/:2:2","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"附录 ","date":"2022-02-07","objectID":"/wireless/:3:0","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"Linux 抓无线包 ","date":"2022-02-07","objectID":"/wireless/:3:1","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["network"],"content":"Wireshark 解密无线包 ","date":"2022-02-07","objectID":"/wireless/:3:2","tags":["wifi","wireless","protocol"],"title":"无线协议学习笔录","uri":"/wireless/"},{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e /* 函数说明: 按照format指定的格式填充字符串str，以 '\\0' 结尾。 函数返回值: 若成功则返回存入数组的字符数，若编码出错则返回负值。 */ int sprintf(char *str, const char *format, ...); ","date":"2022-02-07","objectID":"/sprintf/:1:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"用法分析 sprintf 一般用来把其他类型的数据转换成字符数组储存。它会自动在所写入字符组的末尾加上 NUL 字符来表示字符串的结束，NUL 字符不被计入返回值。 sprintf 和 strcpy 一样，属于无边界检查的一类函数，不建议使用。 ","date":"2022-02-07","objectID":"/sprintf/:2:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"注意事项 对于新写的代码，请抛弃 sprintf，用 snprintf 代替。 ","date":"2022-02-07","objectID":"/sprintf/:3:0","tags":["c"],"title":"C 语言常用库函数-sprintf","uri":"/sprintf/"},{"categories":["programming"],"content":"函数原型 #include \u003cstring.h\u003e char *strcpy(char *dest, const char *src); ","date":"2022-02-07","objectID":"/strcpy/:1:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"用法分析 strcpy 属于无边界检查的一类函数，因此使用起来十分的危险，在标准文档中已经不建议使用。 无边界检查很容易就会发生缓冲溢出的错误，例如: #define BUFSIZ 265 int main(int argc, char **argv) { char buf[BUFSIZ]; strcpy(buf, argv[1]); return 0; } 注意这个例子中 buf 定义了大小为 256，但是 argv[1]却是不限制大小的。由于 strcpy 只知道拷贝到源字串结束，因此一旦 argv[1]的长度大于 BUFSIZ，就会引起缓冲溢出了。 ","date":"2022-02-07","objectID":"/strcpy/:2:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"注意事项 请抛弃 strcpy，用 strncpy 代替，最好用 strlcpy。 ","date":"2022-02-07","objectID":"/strcpy/:3:0","tags":["c"],"title":"C 语言常用库函数-strcpy","uri":"/strcpy/"},{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e int sscanf(const char *str, const char *format, ...); 这里 format 可以是一个或者多个 { %[*][width][{h|l|I64|L}]type | ' ' | '\\t' | '\\n' | 非%符号 } 其中 符号 说明 * 添加则表示满足条件的被过滤 width 表示宽度 h 表示单字节 l 表示双字节 L 表示 4 个字节 I64 表示 8 个字节 type 如 s, d 之类，表示字符串等 ","date":"2022-02-05","objectID":"/sscanf/:1:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"用法分析 ","date":"2022-02-05","objectID":"/sscanf/:2:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"基本用法 sscanf 一般用来从一个 ascii 字符串中读取一些值，基本用法很简单。例如 #include \u003cstdio.h\u003e int main () { char *str = \"121000-13:00:20\"; int s[6]; int i; sscanf(str,\"%2d%2d%2d-%d:%d:%d\", \u0026s[0],\u0026s[1],\u0026s[2],\u0026s[3],\u0026s[4],\u0026s[5]); for(i = 0;i \u003c 6;i++) printf(\"s[%d] = %d\\n\",i,s[i]); return 0; } ","date":"2022-02-05","objectID":"/sscanf/:2:1","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"高级用法 sscanf 提供了简单的模式匹配，其格式为 %[] 。 这里的 [ ] 和正则表达式中是一样的，表示匹配其中出现的字符序列。如果在 [ ] 中使用 ^ ，则是表示取反。 例如: [a-z] 表示小写字母序列,如abc ... [^a-z] 表示除小写字母的字符 举例来说明 #include \u003cstdio.h\u003e int main () { char *str = \"12:10:00-13:00:20\"; char s[6][3]; int i; sscanf(str,\"%[^:]:%[^:]:%[^-]-%[^:]:%[^:]:%[^:]\", s[0],s[1],s[2],s[3],s[4],s[5]); for(i = 0;i \u003c 6;i++) printf(\"s[%d] = %s\\n\",i,s[i]); return 0; } 这个例子分隔出了 str 字符串中的所有数字。其格式字符串分析如下： %[^:] 表示匹配不含 : 的字符串,所以第一个 %[^:] 就匹配了数字字符串 12 ,第二个则匹配了 10 ; 同理， %[^-] 表示匹配不含 - 的字符串,所以匹配字符串 13 ；其他的就不言而寓了。 还是上面的例子，如果我们把格式化字串变为 %[0-9]:%[0-9]:%[0-9]-%[0-9]:%[0-9]:%[0-9] , 将会如何？嘿嘿，一样的结果。因为 %[0-9] 就匹配了数字组成的字符串。 相信这一个例子应该足够说明问题，具体情况具体分析，主要还是靠大家活学活用了。 再举一个复杂点的例子，供参考： #include \u003cstdio.h\u003e /* 获取/和@之间的字符串 */ int main() { const char *s = \"iios/12DDWDFF@122\"; char buf[20]; sscanf(s, \"%*[^/]/%[^@]\", buf); printf(\"%s\\n\", buf); return 0; } ","date":"2022-02-05","objectID":"/sscanf/:2:2","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"注意事项 ","date":"2022-02-05","objectID":"/sscanf/:3:0","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"返回值检查 我们在使用 sscanf 的时候往往会忽略其返回值，事实上，sscanf 的返回值是很有用处的。 当匹配出错的时候其返回值为 EOF，否则返回匹配成功的参数个数，如够一个都没匹配到，就是 0 了。 举例子如下： int main(int argc, char **argv) { int i = 0, j = 0, r; r = sscanf(argv[1], \"%d:%d\", \u0026i, \u0026j); printf(\"r = %d, i = %d, j = %d\\n\", r, i, j); return 0; } 执行结果如下 $ ./main a r = 0, i = 0, j = 0 $ ./main 1 r = 1, i = 1, j = 0 $ ./main 1:2 r = 2, i = 1, j = 2 ","date":"2022-02-05","objectID":"/sscanf/:3:1","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["programming"],"content":"溢出问题 sscanf 最为人诟病的地方，是很容易出现缓冲区溢出错误。实际上 sscanf 是可以避免出现缓冲区溢出的，只要在书写任何字符串解析的格式时，注意加上其缓冲区尺寸的限制。如 #include \u003cstdio.h\u003e int main() { char match[8] = \"12345678\"; // fill with values to test with terminating // null character int len = sizeof(match)-1; const char *input = \"hello world\"; char format[16]; snprintf(format, sizeof(format), \"%%%d[a-z ]\", len); printf(\"format = %s\\n\", format); sscanf(input, format, match); printf(\"match = %s\\n\", match); } 输出为 format = %7[a-z ] match = hello w 这里 format 里面的 %7 就限定了拷贝过来的字符串长度为 7 ，也就是 match 的总长减一。 最后一个字符留给字符串的结尾字符 \\0 ，sscanf 会自动添加。 ","date":"2022-02-05","objectID":"/sscanf/:3:2","tags":["c"],"title":"C语言常用库函数-sscanf","uri":"/sscanf/"},{"categories":["study"],"content":"概述 由于新公司的国外业务占比很高，因此要求托业要过 600 才行。所以入职后前后参加了 2 次考试，分别为 2021.8.24 和 2022.1.16 月份。第一次考了 560 分（250/310），第二次 730 分（350/380）。记录这份文件的目的主要是分享下考试经验，帮助跟我水平类似的人通过托业的考试。 第一次考试基本没做什么准备，只是考前熟悉了一下题型。而从第一次考试到第二次考试，期间虽然间隔了差不多 5 个月的时间，但真正用来复习的也就差不多最后一个多月。因为第二次考试其实是临时决定的，原本的计划是 2022 年后才开始备考。所以这个分享我觉得对于短时间备考的同学更有帮助一些。废话就不多说了，我们开始。 ","date":"2022-02-05","objectID":"/toeic_experience/:1:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"备考经验 ","date":"2022-02-05","objectID":"/toeic_experience/:2:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"原则 拿好你懂的分数，模糊的或者不懂的不要恋战。掌握好时间，题目最多过 2 遍，2遍了还不确定，直接猜，不要逗留 每一题都要当时就填，不懂就猜，不要留空，因为你后面没时间回头填 ","date":"2022-02-05","objectID":"/toeic_experience/:2:1","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"准备工作 考试前先准备好 2 支铅笔和橡皮。铅笔自己考前先试好，确认涂圆形的答题项顺滑。这点我认为很重要，因为如果削的太尖了，涂起来浪费时间，擦起来又不方便。 考试全程都是播放的录音指导考试过程，全英文，建议没考过的同学先做下模拟题熟悉一下旁白的内容。这样你可以知道，哪些时间是你可以利用起来看题或者休息。 进入考场后，桌子上会放有写有准考证号的纸条和你的答题卡。答题卡上的正面以及反面的上半部分都是一些个人信息以及托业官方的调查信息，然后才是题目答案。考前，会有专门的时间（大约 15 分钟）录音指导一步步的填写除答题以外的部分。但是我建议可以乘等待的时间先把答题卡填起来，因为答题卡上有一项需要抄写声明，对于书写慢的同学来说还是有点紧的，为不影响考试情绪，建议提前写好。这时候监考老师一般是不会管的。虽然第一次考试的时候，老师说先不要填写，但是填了也没关系。 我参加的 2 次考试，一次在公司，一次是在外面（托业指定的社会考试地点，某旅店的宴会厅）。考试环境都很安静，基本不会出现一些人提到的外界声音干扰什么的问题，所以这点不用担心。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:2","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"时间分配 托业题量很大，如果不熟悉，根本是来不及做完的。比如我第一次，就整整留下来 5 大题的阅读没有完成。而第二次，经过了练习以后也还是省下了最后 3 道选择题没看，结果是乱填的。所以时间分配很重要。 总时间是 120 分钟，其中 45 分钟听力，75 分钟阅读。 听力 听力其实没什么好说的，因为都是一题一题的过，需要注意的是以下几点关于网上介绍的考试技巧的体会 利用旁白的时间先看看后面要做的题目，比如图片题的图片，短文问答题的问题以及答案。因为旁白的时间一般都比较长，浪费了有点可惜，看看后面的内容也无妨，但是不要抱多大期待。因为对我这样的英文基础，其实看不看影响真的不大。听力好的同学不妨使用。 利用上一题剩下的时间预先审下一题。这个对我来说就太难了，实际操作下来基本没啥用处，做完上一题，基本不剩几秒了，看一下题太过勉强，别费那个心了。(人家的操作是在听短文的时候顺便就把问题做完了，短文结束读问题的时候就跳到下一题去看问题了。我根本做不到听短文的时候还去答问题，一分心短文都听不完整了) 阅读 阅读的 75 分钟时间，建议这样分配，在练习中就通过倒计时来熟悉。 大题 题型 题数 时间 5 句子填空 30 (101~130) 10 分钟 (20 秒一题) 6 短文填空 16 (131~146) 5 分钟 7 单篇阅读(10 篇) 29（147~175） 30 分钟 (3 分钟一篇) 7 多篇阅读(5 篇) 25 (176~200) 30 分钟（5 分钟一篇） ","date":"2022-02-05","objectID":"/toeic_experience/:2:3","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"其他 词汇量 词汇量不是一个月两个月就能提高的。但是对于托业来说，我觉得最好的方式是刷题，然后从题目中记录单词。只是针对这些生词来记忆，可以短期内提高托业的成绩。 听力 说实话，两次考试，我自我觉得听力其实没多少提高，这个确实是硬实力，需要不断的磨耳朵才行。听力上我的建议是针对 Part1 和 Part2 多练习，因为这两项是可以在短期内提高的，而 Part3 和 Part4，有时间就多练多听，没时间。。。就蒙吧，反正我第二次考试 Part3 和 Part4 真正听懂的很少。 另外几个相关的技巧供参考 有的同学记忆不好，比如听到了 A 不确定，听到了 C 又不确定，到听完 D 的时候忘记了 B 是对的还是错的了，猜题的时候就不知道该猜哪个了。考题本和答题卡上都不能做记号，这里有个办法，就是用手指来表示 ABCD，比如左手大拇指表示 A，食指表示 B，依次类推。每一题读完，就用手指的状态表示是否错误。比如如果 A 确定是错的，那么就把大拇指弯曲，B不确定那就保持直着，C错误那就弯曲中指，最后 D 也不确定，那就 BD 里面猜。 对于 Part2 ，关键就是在于听清楚第一个词，4W1H，即 What， Who，Where，When 以及 How 。听清楚了这 4 个词就有 80% 以上的机会答对了。 阅读 单句填空主要是考 单词/文法/词性，所以先知道考点很重要。建议先看答案，再看题。这样有的题目可能马上就能知道答案了，甚至都不需要知道单词是什么意思。这点刷题后自然会有体会。 单篇阅读和多篇阅读也是建议先看题再到文章中去找答案。这样感觉还是要快很多。平时练习可以看一下自己的速度，如果来不及，那么就放弃那些需要看全篇才能找答案的题目。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:4","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"备考资料 先说重点，备考资料里我觉得最有用的就是书和 abceed。 书 \r 2021 新托业模拟题库 我只买了这一套。并且只做了 Part5-Part7 的那两本。前面的听力部分我都是靠手机端软件 abceed 来熟悉。 移动端 \r 背单词：不背单词 + Anki 我背单词的主力软件是不背单词，所有从托业刷题过来的生词都加到生词本，然后每天早上花半小时左右时间复习。 Anki 作为不背单词的补充。因为不背单词有些生词会找不到，所以需要手动记录到 Anki 上进行记忆。当然，托业中遇到的语法，词组等等也都可以记录在 Anki 上。 \r 刷题：abceed + QuizFun 考尚乐 首先我用的是 iphone，这两个软件都需要美区账户才能下载。 abceed 是一个日本人写的软件，可以说是托业最好的移动端软件了，缺点是收费和具体说明文字为日文。软件可以定目标，随时刷题，并即时调整你的成绩。充分的利用碎片时间熟悉题型。我觉得对于听力部分的练习很有用处。而阅读的部分，由于我用的是手机，往往看文章的时候由于显示不全得翻页，严重影响了体验，所以阅读部分对我的帮助应该主要还是在于熟悉题型和收集生词。用 ipad 应该会好很多。建议如果基础不太好的同学花 3 个月左右的时间备考，可以买 3 个月，大概人民币 400 不到，比单月买的便宜很多。 考尚乐 则是台湾人做的一个软件，在台湾托业叫做多益，所以搜考题的时候直接搜多益就可以了。这个软件也是收费的，但是有一些免费的可以用来练习。这个软件我是后来才知道的，所以只是作为一个补充使用。它比 abceed 好的地方在于都是中文解析，不好的地方在于题目有些老，感觉难度相比实际考试偏高。 电脑端 我第一次考试前在淘宝买了一个托业的软件，可以做模拟试题。大概 10 几套试卷，而且每个都有解析，似乎很不错。但是这个软件是基于大屏幕设计的，分辨率需要很高（1920x1080）才能清晰显示。而我的机器分辨率都比较低（穷，老笔记本 :( ）。所以体验一直很差，也就没怎么用。我把软件装在了虚拟机了，随便拉到哪台机器都能用，脱离了 license 的限制。有需要的同学可以跟我索取。 另外就是第二次考试前公司提供的托业官方的复习课程了（offical learning and preparation course）。这里要给公司的福利点赞。这个课程我做了大概一半的样子，之所以没有好好的做完，主要原因还是只有题目和答案，没有解析。有的时候做错了，也不知道错在哪里。 ","date":"2022-02-05","objectID":"/toeic_experience/:2:5","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"附录 ","date":"2022-02-05","objectID":"/toeic_experience/:3:0","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["study"],"content":"答题卡上的个人信息 EDUCATION BACKGROUND - Major en ch Liberal arts 人文学科，比如哲学 Social studies/law 社会学，法学 Accounting/business/economics/finance/marketing/trading 财务/金融/贸易… Sciences (agriculture, computer, mathematics, physic) 科学 Health (medicine, nursing, pharmacy, public health) 健康学 Engineering/architecture 工程架构 Other/none 其他 EDUCATION BACKGROUND - Dgree en ch Primary school 小学 Junior high school 初中 High school (Secondary school) 高中（中学） vocational/technical high school 职业/技术高中 3-Years college 3 年制大学 Community/Junior college (Associate degree) 社区/大专（副学士学位 Undergraduate/bacheior’s degree 本科/学士学位 Graduate/Master’s/doctoral degree 研究生/硕士/博士学位 Language institution 语言机构 Other 其他 ","date":"2022-02-05","objectID":"/toeic_experience/:3:1","tags":["english"],"title":"托业考试经验分享","uri":"/toeic_experience/"},{"categories":["programming"],"content":"函数原型 #include \u003cstdio.h\u003e/* 函数说明: 最多从源串中拷贝size－1个字符到目标串中，然后再在后面加一个0。所 以如果目标串的大小为size的话，将不会溢出。 函数返回值: 若成功则返回存入数组的字符数，若编码出错则返回负值。 */ int snprintf(char *str, size_t size, const char *format, ...); ","date":"2022-02-05","objectID":"/snprintf/:1:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"},{"categories":["programming"],"content":"用法分析 snprintf 和 sprintf 不同的是，当缓冲区不够用时，snprintf 会返回一个大于等于 n 的值，出错时返回一个负值。因此，当返回值是一个不大于 n-1 的非负值时，它可以保证缓冲区是以 NUL 结尾。 snprintf 的正确用法: #include \u003cstdio.h\u003e #define BUFSIZ 16 int main(int argc,char **argv) { char buf[BUFSIZ]; /* 注意这里长度不需要用sizeof(buf)-1，因为snprintf只会拷贝size-1个字节， * 并自己加上NULL结尾 */ snprintf(buf, sizeof(buf), \"%s\", argv[1]); return 0; } ","date":"2022-02-05","objectID":"/snprintf/:2:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"},{"categories":["programming"],"content":"注意事项 不管是 sprintf 还是 snprintf，在使用的时候必须注意被拷贝的字串于作为参数的字串不能相同，因为这会导致不可预知的返回值。例如： #include \u003cstdio.h\u003e int main(int argc, char **argv) { char str[16] = \"hello\"; snprintf(str, sizeof(str), \"%s-%d\", str, 1); printf(\"%s\\n\", str); return 0; } 参考 这份资料 If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results are undefined. ","date":"2022-02-05","objectID":"/snprintf/:3:0","tags":["c"],"title":"C 语言常用库函数-snprintf","uri":"/snprintf/"}]