<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Fog&#39;s Blog</title>
        <link>https://f0ghua.github.io/posts/</link>
        <description>所有文章 | Fog&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 11 Sep 2023 16:33:00 &#43;0800</lastBuildDate><atom:link href="https://f0ghua.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>IPv6 FAQ</title>
    <link>https://f0ghua.github.io/ipv6_faq/</link>
    <pubDate>Mon, 11 Sep 2023 16:33:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/ipv6_faq/</guid>
    <description><![CDATA[本来是想写一篇 IPv6 的文档，可以帮助不熟悉 IPv6 的同事快速了解 IPv6。但是后来发现越写越庞大，太过细节，重复了很多 IPv6 书籍中的内容，从而偏离了原本的]]></description>
</item><item>
    <title>openwrt LUCI工作原理浅析</title>
    <link>https://f0ghua.github.io/openwrt-luci/</link>
    <pubDate>Thu, 04 Aug 2022 17:51:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/openwrt-luci/</guid>
    <description><![CDATA[LUCI 安装 1 2 3 $ ./scripts/feeds update packages luci $ ./scripts/feeds install -a -p luci $ make menuconfig LUCI Collections luci LUCI 的工作原理 首先说明，这里分析的版本为 openwrt-21.02.3 LUCI 可以理解为 lua + UCI 。是用 lua 实现的读写 UCI 配置的一个框架。]]></description>
</item><item>
    <title>内核空间和用户空间通信 - proc 虚拟文件系统</title>
    <link>https://f0ghua.github.io/linux_proc/</link>
    <pubDate>Mon, 01 Aug 2022 17:42:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/linux_proc/</guid>
    <description><![CDATA[概述 使用 proc 虚拟文件系统来在内核空间和用户空间交换数据应该是最常用的一种方式了。我们可以在 /proc 目录下创建一个虚拟的文件，通过读写这个文件实现用户]]></description>
</item><item>
    <title>信息安全技术入门</title>
    <link>https://f0ghua.github.io/security/</link>
    <pubDate>Fri, 01 Jul 2022 09:11:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/security/</guid>
    <description><![CDATA[谈到信息安全，我只能算是个门外汉。但是由于工作需求，经常也会接触一些，所以整理一下备查。顺便也把自己的一些心得分享出来。 关键字 我们在看跟安全]]></description>
</item><item>
    <title>C 语言常用库函数-strncpy</title>
    <link>https://f0ghua.github.io/strncpy/</link>
    <pubDate>Thu, 30 Jun 2022 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/strncpy/</guid>
    <description><![CDATA[函数原型 1 2 3 #include &lt;string.h&gt; char *strncpy(char *dest, const char *src, size_t n); 用法分析 strncpy 由于添加了长度限制，避免了缓冲区溢出的问题。但在使用这个函数的时候必须要注意: strncpy 只有在源字符串的]]></description>
</item><item>
    <title>无线协议学习笔录</title>
    <link>https://f0ghua.github.io/wireless/</link>
    <pubDate>Mon, 07 Feb 2022 13:56:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/wireless/</guid>
    <description><![CDATA[概述 从一次正常的连接说起 先从一次简单的连接看起。测试环境就是一台无线 STA 和一个 AP，以及一台用来抓包的 PC 。 1 2 3 4 5 6 7 8 9 10 +--------+ +-------+ | STA | | AP |]]></description>
</item><item>
    <title>C 语言常用库函数-sprintf</title>
    <link>https://f0ghua.github.io/sprintf/</link>
    <pubDate>Mon, 07 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/sprintf/</guid>
    <description><![CDATA[函数原型 1 2 3 4 5 6 7 8 #include &lt;stdio.h&gt; /* 函数说明: 按照format指定的格式填充字符串str，以 &#39;\0&#39; 结尾。 函数返回值: 若成功则返回存入数组的字符数，若编]]></description>
</item><item>
    <title>C 语言常用库函数-strcpy</title>
    <link>https://f0ghua.github.io/strcpy/</link>
    <pubDate>Mon, 07 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/strcpy/</guid>
    <description><![CDATA[函数原型 1 2 3 #include &lt;string.h&gt; char *strcpy(char *dest, const char *src); 用法分析 strcpy 属于无边界检查的一类函数，因此使用起来十分的危险，在标准文档中已经不建议使用。 无边界检查很容易就会发]]></description>
</item><item>
    <title>C语言常用库函数-sscanf</title>
    <link>https://f0ghua.github.io/sscanf/</link>
    <pubDate>Sat, 05 Feb 2022 20:13:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/sscanf/</guid>
    <description><![CDATA[函数原型 1 2 3 4 5 #include &lt;stdio.h&gt; int sscanf(const char *str, const char *format, ...); 这里 format 可以是一个或者多个 { %[*][width][{h|l|I64|L}]type | ' ' | '\t' | '\n' | 非%符号 } 其中 符号 说明 * 添加则表示满足条件的被过滤 width 表示宽]]></description>
</item><item>
    <title>托业考试经验分享</title>
    <link>https://f0ghua.github.io/toeic_experience/</link>
    <pubDate>Sat, 05 Feb 2022 19:17:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://f0ghua.github.io/toeic_experience/</guid>
    <description><![CDATA[概述 由于新公司的国外业务占比很高，因此要求托业要过 600 才行。所以入职后前后参加了 2 次考试，分别为 2021.8.24 和 2022.1.16 月份。第一次考了 560 分（250/310），]]></description>
</item></channel>
</rss>
